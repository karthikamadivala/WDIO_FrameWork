import { o11yClassErrorHandler, sleep } from '../util.js';
import PercyCaptureMap from './PercyCaptureMap.js';
import * as PercySDK from './PercySDK.js';
import { PercyLogger } from './PercyLogger.js';
import { PERCY_DOM_CHANGING_COMMANDS_ENDPOINTS, CAPTURE_MODES } from '../constants.js';
class _PercyHandler {
    _percyAutoCaptureMode;
    _browser;
    _capabilities;
    _isAppAutomate;
    _framework;
    _testMetadata = {};
    _sessionName;
    _isPercyCleanupProcessingUnderway = false;
    _percyScreenshotCounter = 0;
    _percyDeferredScreenshots = [];
    _percyScreenshotInterval = null;
    _percyCaptureMap;
    constructor(_percyAutoCaptureMode, _browser, _capabilities, _isAppAutomate, _framework) {
        this._percyAutoCaptureMode = _percyAutoCaptureMode;
        this._browser = _browser;
        this._capabilities = _capabilities;
        this._isAppAutomate = _isAppAutomate;
        this._framework = _framework;
        if (!_percyAutoCaptureMode || !CAPTURE_MODES.includes(_percyAutoCaptureMode)) {
            this._percyAutoCaptureMode = 'auto';
        }
    }
    _setSessionName(name) {
        this._sessionName = name;
    }
    async teardown() {
        await new Promise((resolve) => {
            setInterval(() => {
                if (this._percyScreenshotCounter === 0) {
                    resolve();
                }
            }, 1000);
        });
    }
    async percyAutoCapture(eventName, sessionName) {
        try {
            if (eventName) {
                if (!sessionName) {
                    /* Service doesn't wait for handling of browser commands so the below counter is used in teardown method to delay service exit */
                    this._percyScreenshotCounter += 1;
                }
                this._percyCaptureMap?.increment(sessionName ? sessionName : this._sessionName, eventName);
                await (this._isAppAutomate ? PercySDK.screenshotApp(this._percyCaptureMap?.getName(sessionName ? sessionName : this._sessionName, eventName)) : await PercySDK.screenshot(this._browser, this._percyCaptureMap?.getName(sessionName ? sessionName : this._sessionName, eventName)));
                this._percyScreenshotCounter -= 1;
            }
        }
        catch (err) {
            this._percyScreenshotCounter -= 1;
            this._percyCaptureMap?.decrement(sessionName ? sessionName : this._sessionName, eventName);
            PercyLogger.error(`Error while trying to auto capture Percy screenshot ${err}`);
        }
    }
    async before() {
        this._percyCaptureMap = new PercyCaptureMap();
    }
    deferCapture(sessionName, eventName) {
        /* Service doesn't wait for handling of browser commands so the below counter is used in teardown method to delay service exit */
        this._percyScreenshotCounter += 1;
        this._percyDeferredScreenshots.push({ sessionName, eventName });
    }
    isDOMChangingCommand(args) {
        /*
          Percy screenshots which are to be taken on events such as send keys, element click & screenshot are deferred until
          another DOM changing command is seen such that any DOM processing post the previous command is completed
        */
        return (typeof args.method === 'string' && typeof args.endpoint === 'string' &&
            ((args.method === 'POST' &&
                (PERCY_DOM_CHANGING_COMMANDS_ENDPOINTS.includes(args.endpoint) ||
                    (
                    /* click / clear element */
                    args.endpoint.includes('/session/:sessionId/element') &&
                        (args.endpoint.includes('click') ||
                            args.endpoint.includes('clear'))) ||
                    /* execute script sync / async */
                    (args.endpoint.includes('/session/:sessionId/execute') && args.body?.script) ||
                    /* Touch action for Appium */
                    (args.endpoint.includes('/session/:sessionId/touch')))) ||
                (args.method === 'DELETE' && args.endpoint === '/session/:sessionId')));
    }
    async cleanupDeferredScreenshots() {
        this._isPercyCleanupProcessingUnderway = true;
        for (const entry of this._percyDeferredScreenshots) {
            await this.percyAutoCapture(entry.eventName, entry.sessionName);
        }
        this._percyDeferredScreenshots = [];
        this._isPercyCleanupProcessingUnderway = false;
    }
    async browserBeforeCommand(args) {
        try {
            if (!this.isDOMChangingCommand(args)) {
                return;
            }
            do {
                await sleep(1000);
            } while (this._percyScreenshotInterval);
            this._percyScreenshotInterval = setInterval(async () => {
                if (!this._isPercyCleanupProcessingUnderway) {
                    clearInterval(this._percyScreenshotInterval);
                    await this.cleanupDeferredScreenshots();
                    this._percyScreenshotInterval = null;
                }
            }, 1000);
        }
        catch (err) {
            PercyLogger.error(`Error while trying to cleanup deferred screenshots ${err}`);
        }
    }
    async browserAfterCommand(args) {
        try {
            if (!args.endpoint || !this._percyAutoCaptureMode) {
                return;
            }
            let eventName = null;
            const endpoint = args.endpoint;
            if (endpoint.includes('click') && ['click', 'auto'].includes(this._percyAutoCaptureMode)) {
                eventName = 'click';
            }
            else if (endpoint.includes('screenshot') && ['screenshot', 'auto'].includes(this._percyAutoCaptureMode)) {
                eventName = 'screenshot';
            }
            else if (endpoint.includes('actions') && ['auto'].includes(this._percyAutoCaptureMode)) {
                if (args.body && args.body.actions && Array.isArray(args.body.actions) && args.body.actions.length && args.body.actions[0].type === 'key') {
                    eventName = 'keys';
                }
            }
            else if (endpoint.includes('/session/:sessionId/element') && endpoint.includes('value') && ['auto'].includes(this._percyAutoCaptureMode)) {
                eventName = 'keys';
            }
            if (eventName) {
                this.deferCapture(this._sessionName, eventName);
            }
        }
        catch (err) {
            PercyLogger.error(`Error while trying to calculate auto capture parameters ${err}`);
        }
    }
    async afterTest() {
        if (this._percyAutoCaptureMode && this._percyAutoCaptureMode === 'testcase') {
            await this.percyAutoCapture('testcase', null);
        }
    }
    async afterScenario() {
        if (this._percyAutoCaptureMode && this._percyAutoCaptureMode === 'testcase') {
            await this.percyAutoCapture('testcase', null);
        }
    }
}
// https://github.com/microsoft/TypeScript/issues/6543
const PercyHandler = o11yClassErrorHandler(_PercyHandler);
export default PercyHandler;

import UsageStats from './usageStats.js';
import RequestQueueHandler from '../request-handler.js';
import { batchAndPostEvents, sleep } from '../util.js';
import { DATA_BATCH_ENDPOINT, DEFAULT_WAIT_INTERVAL_FOR_PENDING_UPLOADS, DEFAULT_WAIT_TIMEOUT_FOR_PENDING_UPLOADS, LOG_KIND_USAGE_MAP } from '../constants.js';
import { sendScreenshots } from './requestUtils.js';
import { BStackLogger } from '../bstackLogger.js';
class Listener {
    static instance;
    usageStats = UsageStats.getInstance();
    testStartedStats = this.usageStats.testStartedStats;
    testFinishedStats = this.usageStats.testFinishedStats;
    hookStartedStats = this.usageStats.hookStartedStats;
    hookFinishedStats = this.usageStats.hookFinishedStats;
    cbtSessionStats = this.usageStats.cbtSessionStats;
    logEvents = this.usageStats.logStats;
    requestBatcher;
    pendingUploads = 0;
    // Making the constructor private to use singleton pattern
    constructor() {
    }
    static getInstance() {
        if (!Listener.instance) {
            Listener.instance = new Listener();
        }
        return Listener.instance;
    }
    async onWorkerEnd() {
        try {
            await this.uploadPending();
            await this.teardown();
        }
        catch (e) {
            BStackLogger.debug('Exception in onWorkerEnd: ' + e);
        }
    }
    async uploadPending(waitTimeout = DEFAULT_WAIT_TIMEOUT_FOR_PENDING_UPLOADS, waitInterval = DEFAULT_WAIT_INTERVAL_FOR_PENDING_UPLOADS) {
        if ((this.pendingUploads <= 0) || waitTimeout <= 0) {
            return;
        }
        await sleep(waitInterval);
        return this.uploadPending(waitTimeout - waitInterval);
    }
    async teardown() {
        BStackLogger.debug('teardown started');
        RequestQueueHandler.tearDownInvoked = true;
        await this.requestBatcher?.shutdown();
        BStackLogger.debug('teardown ended');
    }
    hookStarted(hookData) {
        try {
            this.hookStartedStats.triggered();
            this.sendBatchEvents(this.getEventForHook('HookRunStarted', hookData));
        }
        catch (e) {
            this.hookStartedStats.failed();
            throw e;
        }
    }
    hookFinished(hookData) {
        try {
            this.hookFinishedStats.triggered(hookData.result);
            this.sendBatchEvents(this.getEventForHook('HookRunFinished', hookData));
        }
        catch (e) {
            this.hookFinishedStats.failed(hookData.result);
            throw e;
        }
    }
    testStarted(testData) {
        try {
            this.testStartedStats.triggered();
            this.sendBatchEvents(this.getEventForHook('TestRunStarted', testData));
        }
        catch (e) {
            this.testStartedStats.failed();
            throw e;
        }
    }
    testFinished(testData) {
        try {
            this.testFinishedStats.triggered(testData.result);
            this.sendBatchEvents(this.getEventForHook('TestRunFinished', testData));
        }
        catch (e) {
            this.testFinishedStats.failed(testData.result);
            throw e;
        }
    }
    logCreated(logs) {
        try {
            this.markLogs('triggered', logs);
            this.sendBatchEvents({
                event_type: 'LogCreated', logs: logs
            });
        }
        catch (e) {
            this.markLogs('failed', logs);
            throw e;
        }
    }
    async onScreenshot(jsonArray) {
        try {
            this.markLogs('triggered', jsonArray);
            this.pendingUploads += 1;
            await sendScreenshots([{
                    event_type: 'LogCreated', logs: jsonArray
                }]);
            this.markLogs('success', jsonArray);
        }
        catch (e) {
            this.markLogs('failed', jsonArray);
            throw e;
        }
        finally {
            this.pendingUploads -= 1;
        }
    }
    cbtSessionCreated(data) {
        try {
            this.cbtSessionStats.triggered();
            this.sendBatchEvents({ event_type: 'CBTSessionCreated', test_run: data });
        }
        catch (e) {
            this.cbtSessionStats.failed();
            throw e;
        }
    }
    markLogs(status, data) {
        if (!data) {
            BStackLogger.debug('No log data');
            return;
        }
        try {
            for (const _log of data) {
                const kind = _log.kind;
                this.logEvents.mark(status, LOG_KIND_USAGE_MAP[kind] || kind);
            }
        }
        catch (e) {
            BStackLogger.debug('Exception in marking logs status ' + e);
            throw e;
        }
    }
    getResult(jsonObject, kind) {
        const runStr = kind === 'test' ? 'test_run' : 'hook_run';
        const runData = jsonObject[runStr];
        return runData?.result;
    }
    sendBatchEvents(jsonObject) {
        if (!this.requestBatcher) {
            this.requestBatcher = RequestQueueHandler.getInstance(async (data) => {
                BStackLogger.debug('callback: called with events ' + data.length);
                try {
                    this.pendingUploads += 1;
                    await batchAndPostEvents(DATA_BATCH_ENDPOINT, 'BATCH_DATA', data);
                    BStackLogger.debug('callback: marking events success ' + data.length);
                    this.eventsSuccess(data);
                }
                catch (e) {
                    BStackLogger.debug('callback: marking events failed ' + data.length);
                    this.eventsFailed(data);
                }
                finally {
                    this.pendingUploads -= 1;
                }
            });
        }
        this.requestBatcher.add(jsonObject);
    }
    eventsFailed(events) {
        for (const event of events) {
            const eventType = event.event_type;
            if (eventType === 'TestRunStarted') {
                this.testStartedStats.failed();
            }
            else if (eventType === 'TestRunFinished') {
                this.testFinishedStats.failed(this.getResult(event, 'test'));
            }
            else if (eventType === 'HookRunStarted') {
                this.hookStartedStats.failed();
            }
            else if (eventType === 'HookRunFinished') {
                this.hookFinishedStats.failed(this.getResult(event, 'hook'));
            }
            else if (eventType === 'CBTSessionCreated') {
                this.cbtSessionStats.failed();
            }
            else if (eventType === 'LogCreated') {
                this.markLogs('failed', event.logs);
            }
        }
    }
    eventsSuccess(events) {
        for (const event of events) {
            const eventType = event.event_type;
            if (eventType === 'TestRunStarted') {
                this.testStartedStats.success();
            }
            else if (eventType === 'TestRunFinished') {
                this.testFinishedStats.success(this.getResult(event, 'test'));
            }
            else if (eventType === 'HookRunStarted') {
                this.hookStartedStats.success();
            }
            else if (eventType === 'HookRunFinished') {
                this.hookFinishedStats.success(this.getResult(event, 'hook'));
            }
            else if (eventType === 'CBTSessionCreated') {
                this.cbtSessionStats.success();
            }
            else if (eventType === 'LogCreated') {
                this.markLogs('success', event.logs);
            }
        }
    }
    getEventForHook(eventType, data) {
        return {
            event_type: eventType, [data.type === 'hook' ? 'hook_run' : 'test_run']: data
        };
    }
}
export default Listener;

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('spacetrim'), require('prettier'), require('prettier/parser-html'), require('moment')) :
    typeof define === 'function' && define.amd ? define(['exports', 'spacetrim', 'prettier', 'prettier/parser-html', 'moment'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["promptbook-core"] = {}, global.spaceTrim));
})(this, (function (exports, spaceTrim) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var spaceTrim__default = /*#__PURE__*/_interopDefaultLegacy(spaceTrim);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    /**
     * This error indicates that the promptbook in a markdown format cannot be parsed into a valid promptbook object
     */
    var PromptbookSyntaxError = /** @class */ (function (_super) {
        __extends(PromptbookSyntaxError, _super);
        function PromptbookSyntaxError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'PromptbookSyntaxError';
            Object.setPrototypeOf(_this, PromptbookSyntaxError.prototype);
            return _this;
        }
        return PromptbookSyntaxError;
    }(Error));

    /**
     * Supported script languages
     */
    var SUPPORTED_SCRIPT_LANGUAGES = ['javascript', 'typescript', 'python'];

    /**
     * Parses the template and returns the list of all parameter names
     *
     * @param template the template with parameters in {curly} braces
     * @returns the list of parameter names
     *
     * @private within the library
     */
    function extractParameters(template) {
        var e_1, _a;
        var matches = template.matchAll(/{\w+}/g);
        var parameterNames = [];
        try {
            for (var matches_1 = __values(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
                var match = matches_1_1.value;
                var parameterName = match[0].slice(1, -1);
                if (!parameterNames.includes(parameterName)) {
                    parameterNames.push(parameterName);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (matches_1_1 && !matches_1_1.done && (_a = matches_1.return)) _a.call(matches_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return parameterNames;
    }

    /**
     * Computes the deepness of the markdown structure.
     *
     * @private within the library
     */
    function countMarkdownStructureDeepness(markdownStructure) {
        var e_1, _a;
        var maxDeepness = 0;
        try {
            for (var _b = __values(markdownStructure.sections), _c = _b.next(); !_c.done; _c = _b.next()) {
                var section = _c.value;
                maxDeepness = Math.max(maxDeepness, countMarkdownStructureDeepness(section));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return maxDeepness + 1;
    }

    /**
     * The maximum number of iterations for a loops
     */
    var LOOP_LIMIT = 1000;

    /**
     * This error type indicates that the error should not happen and its last check before crashing with some other error
     */
    var UnexpectedError = /** @class */ (function (_super) {
        __extends(UnexpectedError, _super);
        function UnexpectedError(message) {
            var _this = _super.call(this, spaceTrim__default["default"](function (block) { return "\n                    ".concat(block(message), "\n\n                    Note: This error should not happen.\n                    It's probbably a bug in the promptbook library\n\n                    Please report issue:\n                    https://github.com/webgptorg/promptbook/issues\n\n                    Or contact us on me@pavolhejny.com\n\n                "); })) || this;
            _this.name = 'UnexpectedError';
            Object.setPrototypeOf(_this, UnexpectedError.prototype);
            return _this;
        }
        return UnexpectedError;
    }(Error));

    /**
     * Parse a markdown string into a MarkdownStructure object.
     *
     * Note: This function does work with code blocks
     * Note: This function does not work with markdown comments
     *
     * @param markdown The markdown string to parse.
     * @returns The MarkdownStructure object.
     *
     * @private within the library
     */
    function markdownToMarkdownStructure(markdown) {
        var e_1, _a;
        var lines = markdown.split('\n');
        var root = { level: 0, title: '', contentLines: [], sections: [], parent: null };
        var current = root;
        var isInsideCodeBlock = false;
        try {
            for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
                var line = lines_1_1.value;
                var headingMatch = line.match(/^(?<mark>#{1,6})\s(?<title>.*)/);
                if (isInsideCodeBlock || !headingMatch) {
                    if (line.startsWith('```')) {
                        isInsideCodeBlock = !isInsideCodeBlock;
                    }
                    current.contentLines.push(line);
                }
                else {
                    var level = headingMatch.groups.mark.length;
                    var title = headingMatch.groups.title.trim();
                    var parent_1 = void 0;
                    if (level > current.level) {
                        // Note: Going deeper (next section is child of current)
                        parent_1 = current;
                    }
                    else {
                        // Note: Going up or staying at the same level (next section is sibling or parent or grandparent,... of current)
                        parent_1 = current;
                        var loopLimit = LOOP_LIMIT;
                        while (parent_1.level !== level - 1) {
                            if (loopLimit-- < 0) {
                                throw new UnexpectedError('Loop limit reached during parsing of markdown structure in `markdownToMarkdownStructure`');
                            }
                            if (parent_1.parent === null /* <- Note: We are in root */) {
                                // [🌻]
                                throw new Error(spaceTrim__default["default"]("\n                                The file has an invalid structure.\n                                The markdown file must have exactly one top-level section.\n                            "));
                            }
                            parent_1 = parent_1.parent;
                        }
                    }
                    var section = { level: level, title: title, contentLines: [], sections: [], parent: parent_1 };
                    parent_1.sections.push(section);
                    current = section;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (root.sections.length === 1) {
            var markdownStructure = parsingMarkdownStructureToMarkdownStructure(root.sections[0]);
            return markdownStructure;
        }
        // [🌻]
        throw new Error('The markdown file must have exactly one top-level section.');
        // return root;
    }
    /**
     * @private
     */
    function parsingMarkdownStructureToMarkdownStructure(parsingMarkdownStructure) {
        var level = parsingMarkdownStructure.level, title = parsingMarkdownStructure.title, contentLines = parsingMarkdownStructure.contentLines, sections = parsingMarkdownStructure.sections;
        return {
            level: level,
            title: title,
            content: spaceTrim__default["default"](contentLines.join('\n')),
            sections: sections.map(parsingMarkdownStructureToMarkdownStructure),
        };
    }

    /**
     * Utility function to extract all list items from markdown
     *
     * Note: It works with both ul and ol
     * Note: It omits list items in code blocks
     * Note: It flattens nested lists
     * Note: It can not work with html syntax and comments
     *
     * @param markdown any valid markdown
     * @returns
     */
    function extractAllListItemsFromMarkdown(markdown) {
        var e_1, _a;
        var lines = markdown.split('\n');
        var listItems = [];
        var isInCodeBlock = false;
        try {
            for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
                var line = lines_1_1.value;
                var trimmedLine = line.trim();
                if (trimmedLine.startsWith('```')) {
                    isInCodeBlock = !isInCodeBlock;
                }
                if (!isInCodeBlock && (trimmedLine.startsWith('-') || trimmedLine.match(/^\d+\./))) {
                    var listItem = trimmedLine.replace(/^-|\d+\./, '').trim();
                    listItems.push(listItem);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return listItems;
    }

    /**
     * Makes first letter of a string uppercase
     *
     */
    function capitalize(word) {
        return word.substring(0, 1).toUpperCase() + word.substring(1);
    }

    /**
     * Extracts all code blocks from markdown.
     *
     * Note: There are 3 simmilar function:
     * - `extractBlock` just extracts the content of the code block which is also used as build-in function for postprocessing
     * - `extractOneBlockFromMarkdown` extracts exactly one code block with language of the code block
     * - `extractAllBlocksFromMarkdown` extracts all code blocks with language of the code block
     *
     * @param markdown any valid markdown
     * @returns code blocks with language and content
     *
     */
    function extractAllBlocksFromMarkdown(markdown) {
        var e_1, _a;
        var codeBlocks = [];
        var lines = markdown.split('\n');
        var currentCodeBlock = null;
        try {
            for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
                var line = lines_1_1.value;
                if (line.startsWith('```')) {
                    var language = line.slice(3).trim() || null;
                    if (currentCodeBlock === null) {
                        currentCodeBlock = { language: language, content: '' };
                    }
                    else {
                        if (language !== null) {
                            // [🌻]
                            throw new Error("".concat(capitalize(currentCodeBlock.language || 'the'), " code block was not closed and already opening new ").concat(language, " code block"));
                        }
                        codeBlocks.push(currentCodeBlock);
                        currentCodeBlock = null;
                    }
                }
                else if (currentCodeBlock !== null) {
                    if (currentCodeBlock.content !== '') {
                        currentCodeBlock.content += '\n';
                    }
                    currentCodeBlock.content += line.split('\\`\\`\\`').join('```') /* <- TODO: Maybe make propper unescape */;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (currentCodeBlock !== null) {
            // [🌻]
            throw new Error("".concat(capitalize(currentCodeBlock.language || 'the'), " code block was not closed at the end of the markdown"));
        }
        return codeBlocks;
    }

    /**
     * Extracts exactly ONE code block from markdown.
     *
     * Note: If there are multiple or no code blocks the function throws an error
     *
     * Note: There are 3 simmilar function:
     * - `extractBlock` just extracts the content of the code block which is also used as build-in function for postprocessing
     * - `extractOneBlockFromMarkdown` extracts exactly one code block with language of the code block
     * - `extractAllBlocksFromMarkdown` extracts all code blocks with language of the code block
     *
     * @param markdown any valid markdown
     * @returns code block with language and content
     */
    function extractOneBlockFromMarkdown(markdown) {
        var codeBlocks = extractAllBlocksFromMarkdown(markdown);
        if (codeBlocks.length !== 1) {
            // TODO: Report more specific place where the error happened
            throw new Error(/* <- [🌻] */ 'There should be exactly one code block in the markdown');
        }
        return codeBlocks[0];
    }
    /***
     * TODO: [🌻] !!! Decide of this is internal util, external util OR validator/postprocessor
     */

    /**
     * Removes HTML or Markdown comments from a string.
     *
     * @param {string} content - The string to remove comments from.
     * @returns {string} The input string with all comments removed.
     */
    function removeContentComments(content) {
        return spaceTrim__default["default"](content.replace(/<!--(.*?)-->/gs, ''));
    }

    /**
     * The version of the Promptbook library
     */
    var PROMPTBOOK_VERSION = '0.44.0-0';

    /**
     * Parses the given script and returns the list of all used variables that are not defined in the script
     *
     * @param script from which to extract the variables
     * @returns the list of variable names
     * @throws {PromptbookSyntaxError} if the script is invalid
     *
     * @private within the promptbookStringToJson
     */
    function extractVariables(script) {
        var variables = [];
        script = "(()=>{".concat(script, "})()");
        try {
            for (var i = 0; i < 100 /* <- TODO: This limit to configuration */; i++)
                try {
                    eval(script);
                }
                catch (error) {
                    if (!(error instanceof ReferenceError)) {
                        throw error;
                    }
                    var undefinedName = error.message.split(' ')[0];
                    /*
                    Note: Remapping error
                          From: [ReferenceError: thing is not defined],
                          To:   [Error: Parameter {thing} is not defined],
                    */
                    if (!undefinedName) {
                        throw error;
                    }
                    if (script.includes(undefinedName + '(')) {
                        script = "const ".concat(undefinedName, " = ()=>'';") + script;
                    }
                    else {
                        variables.push(undefinedName);
                        script = "const ".concat(undefinedName, " = '';") + script;
                    }
                }
        }
        catch (error) {
            if (!(error instanceof Error)) {
                throw error;
            }
            throw new PromptbookSyntaxError(spaceTrim__default["default"](function (block) { return "\n                    Can not extract variables from the script\n\n                    ".concat(block(error.name), ": ").concat(block(error.message), "\n                "); }));
        }
        return variables;
    }

    /**
     * Execution type describes the way how the block is executed
     *
     * @see https://github.com/webgptorg/promptbook#execution-type
     */
    var ExecutionTypes = [
        'PROMPT_TEMPLATE',
        'SIMPLE_TEMPLATE',
        'SCRIPT',
        'PROMPT_DIALOG',
        // <- [🥻] Insert here when making new command
    ];

    /**
     * Units of text measurement
     */
    var EXPECTATION_UNITS = ['CHARACTERS', 'WORDS', 'SENTENCES', 'PARAGRAPHS', 'LINES', 'PAGES'];
    /**
     * TODO: use one helper type> (string_prompt | string_javascript | string_markdown) & string_template
     */

    /**
     * Removes Markdown formatting tags from a string.
     *
     * @param {string} str - The string to remove Markdown tags from.
     * @returns {string} The input string with all Markdown tags removed.
     */
    function removeMarkdownFormatting(str) {
        // Remove bold formatting
        str = str.replace(/\*\*(.*?)\*\*/g, '$1');
        // Remove italic formatting
        str = str.replace(/\*(.*?)\*/g, '$1');
        // Remove code formatting
        str = str.replace(/`(.*?)`/g, '$1');
        return str;
    }

    /**
     * Function parseNumber will parse number from string
     *
     * Unlike Number.parseInt, Number.parseFloat it will never ever result in NaN
     * Note: it also works only with decimal numbers
     *
     * @returns parsed number
     * @throws {PromptbookSyntaxError} if the value is not a number
     *
     * @private within the parseCommand
     */
    function parseNumber(value) {
        var originalValue = value;
        if (typeof value === 'number') {
            value = value.toString(); // <- TODO: Maybe more efficient way to do this
        }
        if (typeof value !== 'string') {
            return 0;
        }
        value = value.trim();
        if (value.startsWith('+')) {
            return parseNumber(value.substring(1));
        }
        if (value.startsWith('-')) {
            var number = parseNumber(value.substring(1));
            if (number === 0) {
                return 0; // <- Note: To prevent -0
            }
            return -number;
        }
        value = value.replace(/,/g, '.');
        value = value.toUpperCase();
        if (value === '') {
            return 0;
        }
        if (value === '♾' || value.startsWith('INF')) {
            return Infinity;
        }
        if (value.includes('/')) {
            var _a = __read(value.split('/'), 2), numerator_ = _a[0], denominator_ = _a[1];
            var numerator = parseNumber(numerator_);
            var denominator = parseNumber(denominator_);
            if (denominator === 0) {
                throw new PromptbookSyntaxError("Unable to parse number from \"".concat(originalValue, "\" because denominator is zero"));
            }
            return numerator / denominator;
        }
        if (/^(NAN|NULL|NONE|UNDEFINED|ZERO|NO.*)$/.test(value)) {
            return 0;
        }
        if (value.includes('E')) {
            var _b = __read(value.split('E'), 2), significand = _b[0], exponent = _b[1];
            return parseNumber(significand) * Math.pow(10, parseNumber(exponent));
        }
        if (!/^[0-9.]+$/.test(value) || value.split('.').length > 2) {
            throw new PromptbookSyntaxError("Unable to parse number from \"".concat(originalValue, "\""));
        }
        var num = parseFloat(value);
        if (isNaN(num)) {
            throw new PromptbookSyntaxError("Unexpected NaN when parsing number from \"".concat(originalValue, "\""));
        }
        return num;
    }
    /**
     * TODO: Maybe use sth. like safe-eval in fraction/calculation case @see https://www.npmjs.com/package/safe-eval
     */

    /**
     * This error indicates errors during the execution of the promptbook
     */
    var PromptbookExecutionError = /** @class */ (function (_super) {
        __extends(PromptbookExecutionError, _super);
        function PromptbookExecutionError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'PromptbookExecutionError';
            Object.setPrototypeOf(_this, PromptbookExecutionError.prototype);
            return _this;
        }
        return PromptbookExecutionError;
    }(Error));

    /**
     * This error occurs during the parameter replacement in the template
     *
     * Note: This is a kindof subtype of PromptbookExecutionError because it occurs during the execution of the pipeline
     */
    var TemplateError = /** @class */ (function (_super) {
        __extends(TemplateError, _super);
        function TemplateError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'TemplateError';
            Object.setPrototypeOf(_this, TemplateError.prototype);
            return _this;
        }
        return TemplateError;
    }(Error));

    /**
     * Replaces parameters in template with values from parameters object
     *
     * @param template the template with parameters in {curly} braces
     * @param parameters the object with parameters
     * @returns the template with replaced parameters
     * @throws {TemplateError} if parameter is not defined, not closed, or not opened
     *
     * @private within the createPromptbookExecutor
     */
    function replaceParameters(template, parameters) {
        var replacedTemplate = template;
        var match;
        var loopLimit = LOOP_LIMIT;
        var _loop_1 = function () {
            if (loopLimit-- < 0) {
                throw new UnexpectedError('Loop limit reached during parameters replacement in `replaceParameters`');
            }
            var precol = match.groups.precol;
            var parameterName = match.groups.parameterName;
            if (parameterName === '') {
                return "continue";
            }
            if (parameterName.indexOf('{') !== -1 || parameterName.indexOf('}') !== -1) {
                throw new TemplateError('Parameter is already opened or not closed');
            }
            if (parameters[parameterName] === undefined) {
                throw new TemplateError("Parameter {".concat(parameterName, "} is not defined"));
            }
            var parameterValue = parameters[parameterName];
            if (parameterValue === undefined) {
                throw new TemplateError("Parameter {".concat(parameterName, "} is not defined"));
            }
            parameterValue = parameterValue.toString();
            if (parameterValue.includes('\n') && /^\s*\W{0,3}\s*$/.test(precol)) {
                parameterValue = parameterValue
                    .split('\n')
                    .map(function (line, index) { return (index === 0 ? line : "".concat(precol).concat(line)); })
                    .join('\n');
            }
            replacedTemplate =
                replacedTemplate.substring(0, match.index + precol.length) +
                    parameterValue +
                    replacedTemplate.substring(match.index + precol.length + parameterName.length + 2);
        };
        while ((match = /^(?<precol>.*){(?<parameterName>\w+)}(.*)/m /* <- Not global */
            .exec(replacedTemplate))) {
            _loop_1();
        }
        // [💫] Check if there are parameters that are not closed properly
        if (/{\w+$/.test(replacedTemplate)) {
            throw new TemplateError('Parameter is not closed');
        }
        // [💫] Check if there are parameters that are not opened properly
        if (/^\w+}/.test(replacedTemplate)) {
            throw new TemplateError('Parameter is not opened');
        }
        return replacedTemplate;
    }

    /**
     * Counts number of characters in the text
     */
    function countCharacters(text) {
        // Remove null characters
        text = text.replace(/\0/g, '');
        // Replace emojis (and also ZWJ sequence) with hyphens
        text = text.replace(/(\p{Extended_Pictographic})\p{Modifier_Symbol}/gu, '$1');
        text = text.replace(/(\p{Extended_Pictographic})[\u{FE00}-\u{FE0F}]/gu, '$1');
        text = text.replace(/\p{Extended_Pictographic}(\u{200D}\p{Extended_Pictographic})*/gu, '-');
        return text.length;
    }

    /**
     * Counts number of lines in the text
     */
    function countLines(text) {
        if (text === '') {
            return 0;
        }
        return text.split('\n').length;
    }

    /**
     * Counts number of pages in the text
     */
    function countPages(text) {
        var sentencesPerPage = 5; // Assuming each page has 5 sentences
        var sentences = text.split(/[.!?]+/).filter(function (sentence) { return sentence.trim() !== ''; });
        var pageCount = Math.ceil(sentences.length / sentencesPerPage);
        return pageCount;
    }

    /**
     * Counts number of paragraphs in the text
     */
    function countParagraphs(text) {
        return text.split(/\n\s*\n/).filter(function (paragraph) { return paragraph.trim() !== ''; }).length;
    }

    /**
     * Split text into sentences
     */
    function splitIntoSentences(text) {
        return text.split(/[.!?]+/).filter(function (sentence) { return sentence.trim() !== ''; });
    }
    /**
     * Counts number of sentences in the text
     */
    function countSentences(text) {
        return splitIntoSentences(text).length;
    }

    var defaultDiacriticsRemovalMap = [
        {
            base: 'A',
            letters: '\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F',
        },
        { base: 'AA', letters: '\uA732' },
        { base: 'AE', letters: '\u00C6\u01FC\u01E2' },
        { base: 'AO', letters: '\uA734' },
        { base: 'AU', letters: '\uA736' },
        { base: 'AV', letters: '\uA738\uA73A' },
        { base: 'AY', letters: '\uA73C' },
        {
            base: 'B',
            letters: '\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181',
        },
        {
            base: 'C',
            letters: '\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E',
        },
        {
            base: 'D',
            letters: '\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779\u00D0',
        },
        { base: 'DZ', letters: '\u01F1\u01C4' },
        { base: 'Dz', letters: '\u01F2\u01C5' },
        {
            base: 'E',
            letters: '\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E',
        },
        { base: 'F', letters: '\u0046\u24BB\uFF26\u1E1E\u0191\uA77B' },
        {
            base: 'G',
            letters: '\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E',
        },
        {
            base: 'H',
            letters: '\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D',
        },
        {
            base: 'I',
            letters: '\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197',
        },
        { base: 'J', letters: '\u004A\u24BF\uFF2A\u0134\u0248' },
        {
            base: 'K',
            letters: '\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2',
        },
        {
            base: 'L',
            letters: '\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780',
        },
        { base: 'LJ', letters: '\u01C7' },
        { base: 'Lj', letters: '\u01C8' },
        { base: 'M', letters: '\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C' },
        {
            base: 'N',
            letters: '\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4',
        },
        { base: 'NJ', letters: '\u01CA' },
        { base: 'Nj', letters: '\u01CB' },
        {
            base: 'O',
            letters: '\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C',
        },
        { base: 'OI', letters: '\u01A2' },
        { base: 'OO', letters: '\uA74E' },
        { base: 'OU', letters: '\u0222' },
        { base: 'OE', letters: '\u008C\u0152' },
        { base: 'oe', letters: '\u009C\u0153' },
        {
            base: 'P',
            letters: '\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754',
        },
        { base: 'Q', letters: '\u0051\u24C6\uFF31\uA756\uA758\u024A' },
        {
            base: 'R',
            letters: '\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782',
        },
        {
            base: 'S',
            letters: '\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784',
        },
        {
            base: 'T',
            letters: '\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786',
        },
        { base: 'TZ', letters: '\uA728' },
        {
            base: 'U',
            letters: '\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244',
        },
        { base: 'V', letters: '\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245' },
        { base: 'VY', letters: '\uA760' },
        {
            base: 'W',
            letters: '\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72',
        },
        { base: 'X', letters: '\u0058\u24CD\uFF38\u1E8A\u1E8C' },
        {
            base: 'Y',
            letters: '\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE',
        },
        {
            base: 'Z',
            letters: '\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762',
        },
        {
            base: 'a',
            letters: '\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250',
        },
        { base: 'aa', letters: '\uA733' },
        { base: 'ae', letters: '\u00E6\u01FD\u01E3' },
        { base: 'ao', letters: '\uA735' },
        { base: 'au', letters: '\uA737' },
        { base: 'av', letters: '\uA739\uA73B' },
        { base: 'ay', letters: '\uA73D' },
        {
            base: 'b',
            letters: '\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253',
        },
        {
            base: 'c',
            letters: '\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184',
        },
        {
            base: 'd',
            letters: '\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A',
        },
        { base: 'dz', letters: '\u01F3\u01C6' },
        {
            base: 'e',
            letters: '\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD',
        },
        { base: 'f', letters: '\u0066\u24D5\uFF46\u1E1F\u0192\uA77C' },
        {
            base: 'g',
            letters: '\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F',
        },
        {
            base: 'h',
            letters: '\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265',
        },
        { base: 'hv', letters: '\u0195' },
        {
            base: 'i',
            letters: '\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131',
        },
        { base: 'j', letters: '\u006A\u24D9\uFF4A\u0135\u01F0\u0249' },
        {
            base: 'k',
            letters: '\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3',
        },
        {
            base: 'l',
            letters: '\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747',
        },
        { base: 'lj', letters: '\u01C9' },
        { base: 'm', letters: '\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F' },
        {
            base: 'n',
            letters: '\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5',
        },
        { base: 'nj', letters: '\u01CC' },
        {
            base: 'o',
            letters: '\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275',
        },
        { base: 'oi', letters: '\u01A3' },
        { base: 'ou', letters: '\u0223' },
        { base: 'oo', letters: '\uA74F' },
        {
            base: 'p',
            letters: '\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755',
        },
        { base: 'q', letters: '\u0071\u24E0\uFF51\u024B\uA757\uA759' },
        {
            base: 'r',
            letters: '\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783',
        },
        {
            base: 's',
            letters: '\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B',
        },
        {
            base: 't',
            letters: '\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787',
        },
        { base: 'tz', letters: '\uA729' },
        {
            base: 'u',
            letters: '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289',
        },
        { base: 'v', letters: '\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C' },
        { base: 'vy', letters: '\uA761' },
        {
            base: 'w',
            letters: '\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73',
        },
        { base: 'x', letters: '\u0078\u24E7\uFF58\u1E8B\u1E8D' },
        {
            base: 'y',
            letters: '\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF',
        },
        {
            base: 'z',
            letters: '\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763',
        },
    ];
    /**
     * Map of letters from diacritic variant to diacritless variant
     * Contains lowercase and uppercase separatelly
     *
     * > "á" => "a"
     * > "ě" => "e"
     * > "Ă" => "A"
     * > ...
     */
    var DIACRITIC_VARIANTS_LETTERS = {};
    // tslint:disable-next-line: prefer-for-of
    for (var i = 0; i < defaultDiacriticsRemovalMap.length; i++) {
        var letters = defaultDiacriticsRemovalMap[i].letters;
        // tslint:disable-next-line: prefer-for-of
        for (var j = 0; j < letters.length; j++) {
            DIACRITIC_VARIANTS_LETTERS[letters[j]] =
                defaultDiacriticsRemovalMap[i].base;
        }
    }
    // <- TODO: !!!! Put to maker function
    /*
      @see https://stackoverflow.com/questions/990904/remove-accents-diacritics-in-a-string-in-javascript
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at

           http://www.apache.org/licenses/LICENSE-2.0

       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
    */

    /**
     *
     */
    function removeDiacritics(input) {
        /*eslint no-control-regex: "off"*/
        return input.replace(/[^\u0000-\u007E]/g, function (a) {
            return DIACRITIC_VARIANTS_LETTERS[a] || a;
        });
    }

    /**
     * Counts number of words in the text
     */
    function countWords(text) {
        text = text.replace(/[\p{Extended_Pictographic}]/gu, 'a');
        text = removeDiacritics(text);
        return text.split(/[^a-zа-я0-9]+/i).filter(function (word) { return word.length > 0; }).length;
    }

    /**
     * Index of all counter functions
     */
    var CountUtils = {
        CHARACTERS: countCharacters,
        WORDS: countWords,
        SENTENCES: countSentences,
        PARAGRAPHS: countParagraphs,
        LINES: countLines,
        PAGES: countPages,
    };

    /**
     * Function isValidJsonString will tell you if the string is valid JSON or not
     */
    function isValidJsonString(value) {
        try {
            JSON.parse(value);
            return true;
        }
        catch (error) {
            if (!(error instanceof Error)) {
                throw error;
            }
            if (error.message.includes('Unexpected token')) {
                return false;
            }
            return false;
        }
    }

    /* tslint:disable */
    /*
    TODO: Tests
    expect(encodeRoutePath({ uriId: 'VtG7sR9rRJqwNEdM2', name: 'Moje tabule' })).toEqual('/VtG7sR9rRJqwNEdM2/Moje tabule');
    expect(encodeRoutePath({ uriId: 'VtG7sR9rRJqwNEdM2', name: 'ěščřžžýáíúů' })).toEqual('/VtG7sR9rRJqwNEdM2/escrzyaieuu');
    expect(encodeRoutePath({ uriId: 'VtG7sR9rRJqwNEdM2', name: '  ahoj  ' })).toEqual('/VtG7sR9rRJqwNEdM2/ahoj');
    expect(encodeRoutePath({ uriId: 'VtG7sR9rRJqwNEdM2', name: '  ahoj_ahojAhoj    ahoj  ' })).toEqual('/VtG7sR9rRJqwNEdM2/ahoj-ahoj-ahoj-ahoj');
    */
    function normalizeTo_SCREAMING_CASE(sentence) {
        var e_1, _a;
        var charType;
        var lastCharType = 'OTHER';
        var normalizedName = '';
        try {
            for (var sentence_1 = __values(sentence), sentence_1_1 = sentence_1.next(); !sentence_1_1.done; sentence_1_1 = sentence_1.next()) {
                var char = sentence_1_1.value;
                var normalizedChar = void 0;
                if (/^[a-z]$/.test(char)) {
                    charType = 'LOWERCASE';
                    normalizedChar = char.toUpperCase();
                }
                else if (/^[A-Z]$/.test(char)) {
                    charType = 'UPPERCASE';
                    normalizedChar = char;
                }
                else if (/^[0-9]$/.test(char)) {
                    charType = 'NUMBER';
                    normalizedChar = char;
                }
                else if (/^\/$/.test(char)) {
                    charType = 'SLASH';
                    normalizedChar = char;
                }
                else {
                    charType = 'OTHER';
                    normalizedChar = '_';
                }
                if (charType !== lastCharType &&
                    !(lastCharType === 'UPPERCASE' && charType === 'LOWERCASE') &&
                    !(lastCharType === 'NUMBER') &&
                    !(charType === 'NUMBER')) {
                    normalizedName += '_';
                }
                normalizedName += normalizedChar;
                lastCharType = charType;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sentence_1_1 && !sentence_1_1.done && (_a = sentence_1.return)) _a.call(sentence_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        normalizedName = normalizedName.replace(/_+/g, '_');
        normalizedName = normalizedName.replace(/_?\/_?/g, '/');
        normalizedName = normalizedName.replace(/^_/, '');
        normalizedName = normalizedName.replace(/_$/, '');
        return normalizedName;
    }
    /**
     * TODO: [🌺] Use some intermediate util splitWords
     */

    /* tslint:disable */
    function normalizeTo_camelCase(sentence, __firstLetterCapital) {
        var e_1, _a;
        if (__firstLetterCapital === void 0) { __firstLetterCapital = false; }
        var charType;
        var lastCharType = null;
        var normalizedName = '';
        try {
            for (var sentence_1 = __values(sentence), sentence_1_1 = sentence_1.next(); !sentence_1_1.done; sentence_1_1 = sentence_1.next()) {
                var char = sentence_1_1.value;
                var normalizedChar = void 0;
                if (/^[a-z]$/.test(char)) {
                    charType = 'LOWERCASE';
                    normalizedChar = char;
                }
                else if (/^[A-Z]$/.test(char)) {
                    charType = 'UPPERCASE';
                    normalizedChar = char.toLowerCase();
                }
                else if (/^[0-9]$/.test(char)) {
                    charType = 'NUMBER';
                    normalizedChar = char;
                }
                else {
                    charType = 'OTHER';
                    normalizedChar = '';
                }
                if (!lastCharType) {
                    if (__firstLetterCapital) {
                        normalizedChar = normalizedChar.toUpperCase(); //TODO: DRY
                    }
                }
                else if (charType !== lastCharType &&
                    !(charType === 'LOWERCASE' && lastCharType === 'UPPERCASE') &&
                    !(lastCharType === 'NUMBER') &&
                    !(charType === 'NUMBER')) {
                    normalizedChar = normalizedChar.toUpperCase(); //TODO: [🌺] DRY
                }
                normalizedName += normalizedChar;
                lastCharType = charType;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sentence_1_1 && !sentence_1_1.done && (_a = sentence_1.return)) _a.call(sentence_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return normalizedName;
    }
    /**
     * TODO: [🌺] Use some intermediate util splitWords
     */

    function normalizeTo_PascalCase(sentence) {
        return normalizeTo_camelCase(sentence, true);
    }

    /**
     * Parses one line of ul/ol to command
     *
     * @returns parsed command object
     * @throws {PromptbookSyntaxError} if the command is invalid
     *
     * @private within the promptbookStringToJson
     */
    function parseCommand(listItem) {
        var e_1, _a;
        if (listItem.includes('\n') || listItem.includes('\r')) {
            throw new PromptbookSyntaxError('Command can not contain new line characters:');
        }
        var type = listItem.trim();
        type = type.split('`').join('');
        type = type.split('"').join('');
        type = type.split("'").join('');
        type = type.split('~').join('');
        type = type.split('[').join('');
        type = type.split(']').join('');
        type = type.split('(').join('');
        type = type.split(')').join('');
        type = normalizeTo_SCREAMING_CASE(type);
        type = type.split('DIALOGUE').join('DIALOG');
        var listItemParts = listItem
            .split(' ')
            .map(function (part) { return part.trim(); })
            .filter(function (item) { return item !== ''; })
            .filter(function (item) { return !/^PTBK$/i.test(item); })
            .filter(function (item) { return !/^PROMPTBOOK$/i.test(item); })
            .map(removeMarkdownFormatting);
        if (type.startsWith('URL') ||
            type.startsWith('PTBK_URL') ||
            type.startsWith('PTBKURL') ||
            type.startsWith('PROMPTBOOK_URL') ||
            type.startsWith('PROMPTBOOKURL') ||
            type.startsWith('HTTPS')) {
            if (!(listItemParts.length === 2 || (listItemParts.length === 1 && type.startsWith('HTTPS')))) {
                throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                        Invalid PROMPTBOOK_URL command:\n\n                        - ".concat(listItem, "\n                    ")));
            }
            var promptbookUrlString = listItemParts.pop();
            var promptbookUrl = new URL(promptbookUrlString);
            if (promptbookUrl.protocol !== 'https:') {
                throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                        Invalid PROMPTBOOK_URL command:\n\n                        - ".concat(listItem, "\n\n                        Protocol must be HTTPS\n                    ")));
            }
            if (promptbookUrl.hash !== '') {
                throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                        Invalid PROMPTBOOK_URL command:\n\n                        - ".concat(listItem, "\n\n                        URL must not contain hash\n                        Hash is used for identification of the prompt template in the pipeline\n                    ")));
            }
            return {
                type: 'PROMPTBOOK_URL',
                promptbookUrl: promptbookUrl,
            };
        }
        else if (type.startsWith('PROMPTBOOK_VERSION') || type.startsWith('PTBK_VERSION')) {
            if (listItemParts.length !== 2) {
                throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                        Invalid PROMPTBOOK_VERSION command:\n\n                        - ".concat(listItem, "\n                    ")));
            }
            var promptbookVersion = listItemParts.pop();
            // TODO: Validate version
            return {
                type: 'PROMPTBOOK_VERSION',
                promptbookVersion: promptbookVersion,
            };
        }
        else if (type.startsWith('EXECUTE') ||
            type.startsWith('EXEC') ||
            type.startsWith('PROMPT_DIALOG') ||
            type.startsWith('SIMPLE_TEMPLATE')) {
            var executionTypes = ExecutionTypes.filter(function (executionType) { return type.includes(executionType); });
            if (executionTypes.length !== 1) {
                throw new PromptbookSyntaxError(spaceTrim__default["default"](function (block) { return "\n                        Unknown execution type in command:\n\n                        - ".concat(listItem, "\n\n                        Supported execution types are:\n                        ").concat(block(ExecutionTypes.join(', ')), "\n                    "); }));
            }
            return {
                type: 'EXECUTE',
                executionType: executionTypes[0],
            };
        }
        else if (type.startsWith('MODEL')) {
            // TODO: Make this more elegant and dynamically
            if (type.startsWith('MODEL_VARIANT')) {
                if (type === 'MODEL_VARIANT_CHAT') {
                    return {
                        type: 'MODEL',
                        key: 'modelVariant',
                        value: 'CHAT',
                    };
                }
                else if (type === 'MODEL_VARIANT_COMPLETION') {
                    return {
                        type: 'MODEL',
                        key: 'modelVariant',
                        value: 'COMPLETION',
                    };
                }
                else {
                    throw new PromptbookSyntaxError(spaceTrim__default["default"](function (block) { return "\n                            Unknown model variant in command:\n\n                            - ".concat(listItem, "\n\n                            Supported variants are:\n                            ").concat(block(['CHAT', 'COMPLETION'].join(', ')), "\n                        "); }));
                }
            }
            if (type.startsWith('MODEL_NAME')) {
                return {
                    type: 'MODEL',
                    key: 'modelName',
                    value: listItemParts.pop(),
                };
            }
            else {
                throw new PromptbookSyntaxError(spaceTrim__default["default"](function (block) { return "\n                          Unknown model key in command:\n\n                          - ".concat(listItem, "\n\n                          Supported model keys are:\n                          ").concat(block(['variant', 'name'].join(', ')), "\n\n                          Example:\n\n                          - MODEL VARIANT Chat\n                          - MODEL NAME gpt-4\n                    "); }));
            }
        }
        else if (type.startsWith('PARAM') ||
            type.startsWith('INPUT_PARAM') ||
            type.startsWith('OUTPUT_PARAM') ||
            listItem.startsWith('{') ||
            listItem.startsWith('> {') /* <- Note: This is a bit hack to parse return parameters defined at the end of each section */) {
            var parametersMatch = listItem.match(/\{(?<parameterName>[a-z0-9_]+)\}[^\S\r\n]*(?<parameterDescription>.*)$/im);
            if (!parametersMatch || !parametersMatch.groups || !parametersMatch.groups.parameterName) {
                throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                        Invalid parameter in command:\n\n                        - ".concat(listItem, "\n                    ")));
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var _b = parametersMatch.groups, parameterName = _b.parameterName, parameterDescription = _b.parameterDescription;
            if (parameterDescription && parameterDescription.match(/\{(?<parameterName>[a-z0-9_]+)\}/im)) {
                throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                        Parameter {".concat(parameterName, "} can not contain another parameter in description:\n\n                        - ").concat(listItem, "\n                    ")));
            }
            var isInput = type.startsWith('INPUT');
            var isOutput = type.startsWith('OUTPUT');
            if (listItem.startsWith('> {')) {
                isInput = false;
                isOutput = false;
            }
            return {
                type: 'PARAMETER',
                parameterName: parameterName,
                parameterDescription: parameterDescription.trim() || null,
                isInput: isInput,
                isOutput: isOutput,
            };
        }
        else if (type.startsWith('JOKER')) {
            if (listItemParts.length !== 2) {
                throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                Invalid JOKER command:\n\n                - ".concat(listItem, "\n            ")));
            }
            var parametersMatch = (listItemParts.pop() || '').match(/^\{(?<parameterName>[a-z0-9_]+)\}$/im);
            if (!parametersMatch || !parametersMatch.groups || !parametersMatch.groups.parameterName) {
                throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                      Invalid parameter in command:\n\n                      - ".concat(listItem, "\n                  ")));
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var parameterName = parametersMatch.groups.parameterName;
            return {
                type: 'JOKER',
                parameterName: parameterName,
            };
        }
        else if (type.startsWith('POSTPROCESS') || type.startsWith('POST_PROCESS')) {
            if (listItemParts.length !== 2) {
                throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                Invalid POSTPROCESSING command:\n\n                - ".concat(listItem, "\n            ")));
            }
            var functionName = listItemParts.pop();
            return {
                type: 'POSTPROCESS',
                functionName: functionName,
            };
        }
        else if (type.startsWith('EXPECT_JSON')) {
            return {
                type: 'EXPECT_FORMAT',
                format: 'JSON',
            };
            // [🥤]
        }
        else if (type.startsWith('EXPECT')) {
            try {
                listItemParts.shift();
                var sign = void 0;
                var signRaw = listItemParts.shift();
                if (/^exact/i.test(signRaw)) {
                    sign = 'EXACTLY';
                }
                else if (/^min/i.test(signRaw)) {
                    sign = 'MINIMUM';
                }
                else if (/^max/i.test(signRaw)) {
                    sign = 'MAXIMUM';
                }
                else {
                    throw new PromptbookSyntaxError("Invalid sign \"".concat(signRaw, "\", expected EXACTLY, MIN or MAX"));
                }
                var amountRaw = listItemParts.shift();
                var amount = parseNumber(amountRaw);
                if (amount < 0) {
                    throw new PromptbookSyntaxError('Amount must be positive number or zero');
                }
                if (amount !== Math.floor(amount)) {
                    throw new PromptbookSyntaxError('Amount must be whole number');
                }
                var unitRaw = listItemParts.shift();
                var unit = undefined;
                try {
                    for (var EXPECTATION_UNITS_1 = __values(EXPECTATION_UNITS), EXPECTATION_UNITS_1_1 = EXPECTATION_UNITS_1.next(); !EXPECTATION_UNITS_1_1.done; EXPECTATION_UNITS_1_1 = EXPECTATION_UNITS_1.next()) {
                        var existingUnit = EXPECTATION_UNITS_1_1.value;
                        var existingUnitText = existingUnit;
                        existingUnitText = existingUnitText.substring(0, existingUnitText.length - 1);
                        if (existingUnitText === 'CHARACTER') {
                            existingUnitText = 'CHAR';
                        }
                        if (new RegExp("^".concat(existingUnitText.toLowerCase())).test(unitRaw.toLowerCase()) ||
                            new RegExp("^".concat(unitRaw.toLowerCase())).test(existingUnitText.toLowerCase())) {
                            if (unit !== undefined) {
                                throw new PromptbookSyntaxError("Ambiguous unit \"".concat(unitRaw, "\""));
                            }
                            unit = existingUnit;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (EXPECTATION_UNITS_1_1 && !EXPECTATION_UNITS_1_1.done && (_a = EXPECTATION_UNITS_1.return)) _a.call(EXPECTATION_UNITS_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (unit === undefined) {
                    throw new PromptbookSyntaxError("Invalid unit \"".concat(unitRaw, "\""));
                }
                return {
                    type: 'EXPECT_AMOUNT',
                    sign: sign,
                    unit: unit,
                    amount: amount,
                };
            }
            catch (error) {
                if (!(error instanceof Error)) {
                    throw error;
                }
                throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                  Invalid EXPECT command; ".concat(error.message, ":\n\n                  - ").concat(listItem, "\n              ")));
            }
            /*
        } else if (type.startsWith('__________________')) {
            // <- [🥻] Insert here when making new command
        */
        }
        else {
            throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                    Unknown command:\n\n                    - ".concat(listItem, "\n\n                    Supported commands are:\n                    - PROMPTBOOK_URL <url>\n                    - PROMPTBOOK_VERSION <version>\n                    - EXECUTE PROMPT TEMPLATE\n                    - EXECUTE SIMPLE TEMPLATE\n                    -         SIMPLE TEMPLATE\n                    - EXECUTE SCRIPT\n                    - EXECUTE PROMPT_DIALOG'\n                    -         PROMPT_DIALOG'\n                    - MODEL NAME <name>\n                    - MODEL VARIANT <\"Chat\"|\"Completion\">\n                    - INPUT  PARAM {<name>} <description>\n                    - OUTPUT PARAM {<name>} <description>\n                    - POSTPROCESS `{functionName}`\n                    - JOKER {<name>}\n                    - EXPECT JSON\n                    - EXPECT <\"Exactly\"|\"Min\"|\"Max\"> <number> <\"Chars\"|\"Words\"|\"Sentences\"|\"Paragraphs\"|\"Pages\">\n\n                ")));
        }
    }

    /**
     * Parse promptbook from string format to JSON format
     *
     * @throws {PromptbookSyntaxError} if the promptbook string is not valid
     *
     * Note: This function does not validate logic of the pipeline only the syntax
     */
    function promptbookStringToJson(promptbookString) {
        var e_1, _a, e_2, _b;
        var promptbookJson = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            title: undefined /* <- Note: Putting here placeholder to keep `title` on top at final JSON */,
            promptbookUrl: undefined /* <- Note: Putting here placeholder to keep `promptbookUrl` on top at final JSON */,
            promptbookVersion: PROMPTBOOK_VERSION,
            description: undefined /* <- Note: Putting here placeholder to keep `description` on top at final JSON */,
            parameters: [],
            promptTemplates: [],
        };
        // =============================================================
        // Note: 1️⃣ Normalization of the PROMPTBOOK string
        promptbookString = removeContentComments(promptbookString);
        promptbookString = promptbookString.replaceAll(/`\{(?<parameterName>[a-z0-9_]+)\}`/gi, '{$<parameterName>}');
        promptbookString = promptbookString.replaceAll(/`->\s+\{(?<parameterName>[a-z0-9_]+)\}`/gi, '-> {$<parameterName>}');
        // =============================================================
        ///Note: 2️⃣ Function for adding parameters
        var addParam = function (parameterCommand) {
            var parameterName = parameterCommand.parameterName, parameterDescription = parameterCommand.parameterDescription, isInput = parameterCommand.isInput, isOutput = parameterCommand.isOutput;
            var existingParameter = promptbookJson.parameters.find(function (parameter) { return parameter.name === parameterName; });
            if (existingParameter &&
                existingParameter.description &&
                existingParameter.description !== parameterDescription &&
                parameterDescription) {
                throw new PromptbookSyntaxError(spaceTrim__default["default"](function (block) { return "\n                        Parameter {".concat(parameterName, "} is defined multiple times with different description.\n\n                        First definition:\n                        ").concat(block(existingParameter.description || '[undefined]'), "\n\n                        Second definition:\n                        ").concat(block(parameterDescription || '[undefined]'), "\n                    "); }));
            }
            if (existingParameter) {
                if (parameterDescription) {
                    existingParameter.description = parameterDescription;
                }
            }
            else {
                promptbookJson.parameters.push({
                    name: parameterName,
                    description: parameterDescription || undefined,
                    isInput: isInput,
                    isOutput: isOutput,
                });
            }
        };
        // =============================================================
        // Note: 3️⃣ Parse the dynamic part - the template pipeline
        var markdownStructure = markdownToMarkdownStructure(promptbookString);
        var markdownStructureDeepness = countMarkdownStructureDeepness(markdownStructure);
        if (markdownStructureDeepness !== 2) {
            throw new PromptbookSyntaxError(spaceTrim__default["default"]("\n                Invalid markdown structure.\n                The markdown must have exactly 2 levels of headings (one top-level section and one section for each template).\n                Now it has ".concat(markdownStructureDeepness, " levels of headings.\n            ")));
        }
        promptbookJson.title = markdownStructure.title;
        // TODO: [1] DRY description
        var description = markdownStructure.content;
        // Note: Remove codeblocks
        description = description.split(/^```.*^```/gms).join('');
        //Note: Remove lists and return statement
        description = description.split(/^(?:(?:-)|(?:\d\))|(?:`?->))\s+.*$/gm).join('');
        description = spaceTrim__default["default"](description);
        if (description === '') {
            description = undefined;
        }
        promptbookJson.description = description;
        var defaultModelRequirements = {};
        var listItems = extractAllListItemsFromMarkdown(markdownStructure.content);
        try {
            for (var listItems_1 = __values(listItems), listItems_1_1 = listItems_1.next(); !listItems_1_1.done; listItems_1_1 = listItems_1.next()) {
                var listItem = listItems_1_1.value;
                var command = parseCommand(listItem);
                switch (command.type) {
                    case 'PROMPTBOOK_URL':
                        promptbookJson.promptbookUrl = command.promptbookUrl.href;
                        break;
                    case 'PROMPTBOOK_VERSION':
                        promptbookJson.promptbookVersion = command.promptbookVersion;
                        break;
                    case 'MODEL':
                        defaultModelRequirements[command.key] = command.value;
                        break;
                    case 'PARAMETER':
                        addParam(command);
                        break;
                    default:
                        throw new PromptbookSyntaxError("Command ".concat(command.type, " is not allowed in the head of the promptbook ONLY at the prompt template block"));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (listItems_1_1 && !listItems_1_1.done && (_a = listItems_1.return)) _a.call(listItems_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var _loop_1 = function (section) {
            var e_3, _e, e_4, _f, e_5, _g;
            // TODO: Parse prompt template description (the content out of the codeblock and lists)
            var templateModelRequirements = __assign({}, defaultModelRequirements);
            var listItems_3 = extractAllListItemsFromMarkdown(section.content);
            var dependentParameterNames = [];
            var executionType = 'PROMPT_TEMPLATE';
            var jokers = [];
            var postprocessing = [];
            var expectAmount = {};
            var expectFormat = undefined;
            var isExecutionTypeChanged = false;
            try {
                for (var listItems_2 = (e_3 = void 0, __values(listItems_3)), listItems_2_1 = listItems_2.next(); !listItems_2_1.done; listItems_2_1 = listItems_2.next()) {
                    var listItem = listItems_2_1.value;
                    var command = parseCommand(listItem);
                    switch (command.type) {
                        case 'JOKER':
                            jokers.push(command.parameterName);
                            dependentParameterNames.push(command.parameterName);
                            break;
                        case 'EXECUTE':
                            if (isExecutionTypeChanged) {
                                throw new PromptbookSyntaxError('Execution type is already defined in the prompt template. It can be defined only once.');
                            }
                            executionType = command.executionType;
                            isExecutionTypeChanged = true;
                            break;
                        case 'MODEL':
                            templateModelRequirements[command.key] = command.value;
                            break;
                        case 'PARAMETER':
                            // Note: This is just for detecting resulitng parameter name
                            addParam(command);
                            break;
                        case 'POSTPROCESS':
                            postprocessing.push(command.functionName);
                            break;
                        case 'EXPECT_AMOUNT':
                            // eslint-disable-next-line no-case-declarations
                            var unit = command.unit.toLowerCase();
                            expectAmount[unit] = expectAmount[unit] || {};
                            if (command.sign === 'MINIMUM' || command.sign === 'EXACTLY') {
                                if (expectAmount[unit].min !== undefined) {
                                    throw new PromptbookSyntaxError("Already defined minumum ".concat(expectAmount[unit].min, " ").concat(command.unit.toLowerCase(), ", now trying to redefine it to ").concat(command.amount));
                                }
                                expectAmount[unit].min = command.amount;
                            } /* not else */
                            if (command.sign === 'MAXIMUM' || command.sign === 'EXACTLY') {
                                if (expectAmount[unit].max !== undefined) {
                                    throw new PromptbookSyntaxError("Already defined maximum ".concat(expectAmount[unit].max, " ").concat(command.unit.toLowerCase(), ", now trying to redefine it to ").concat(command.amount));
                                }
                                expectAmount[unit].max = command.amount;
                            }
                            break;
                        case 'EXPECT_FORMAT':
                            if (expectFormat !== undefined && command.format !== expectFormat) {
                                throw new PromptbookSyntaxError("Expect format is already defined to \"".concat(expectFormat, "\". Now you try to redefine it by \"").concat(command.format, "\"."));
                            }
                            expectFormat = command.format;
                            break;
                        default:
                            throw new PromptbookSyntaxError("Command ".concat(command.type, " is not allowed in the block of the prompt template ONLY at the head of the promptbook"));
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (listItems_2_1 && !listItems_2_1.done && (_e = listItems_2.return)) _e.call(listItems_2);
                }
                finally { if (e_3) throw e_3.error; }
            }
            var _h = extractOneBlockFromMarkdown(section.content), language = _h.language, content = _h.content;
            if (executionType === 'SCRIPT') {
                if (!language) {
                    throw new PromptbookSyntaxError('You must specify the language of the script in the prompt template');
                }
                else if (!SUPPORTED_SCRIPT_LANGUAGES.includes(language)) {
                    throw new PromptbookSyntaxError(spaceTrim__default["default"](function (block) { return "\n                            Script language ".concat(language, " is not supported.\n\n                            Supported languages are:\n                            ").concat(block(SUPPORTED_SCRIPT_LANGUAGES.join(', ')), "\n\n                        "); }));
                }
            }
            var lastLine = section.content.split('\n').pop();
            var match = /^->\s*\{(?<resultingParamName>[a-z0-9_]+)\}/im.exec(lastLine);
            if (!match || match.groups === undefined || match.groups.resultingParamName === undefined) {
                throw new PromptbookSyntaxError(spaceTrim__default["default"](function (block) { return "\n                        Invalid template - each section must end with \"-> {...}\"\n\n                        Invalid section:\n                        ".concat(block(
                // TODO: Show code of invalid sections each time + DRY
                section.content
                    .split('\n')
                    .map(function (line) { return "> ".concat(line); })
                    .join('\n')), "\n                        "); }));
            }
            var resultingParameterName = match.groups.resultingParamName;
            // TODO: [1] DRY description
            var description_1 = section.content;
            // Note: Remove codeblocks
            description_1 = description_1.split(/^```.*^```/gms).join('');
            //Note: Remove lists and return statement
            description_1 = description_1.split(/^(?:(?:-)|(?:\d\))|(?:`?->))\s+.*$/gm).join('');
            description_1 = spaceTrim__default["default"](description_1);
            if (description_1 === '') {
                description_1 = undefined;
            }
            if (Object.keys(jokers).length === 0) {
                jokers = undefined;
            }
            if (Object.keys(expectAmount).length === 0) {
                expectAmount = undefined;
            }
            if (Object.keys(postprocessing).length === 0) {
                postprocessing = undefined;
            }
            try {
                for (var _j = (e_4 = void 0, __values(__spreadArray(__spreadArray(__spreadArray([], __read(extractParameters(section.title)), false), __read(extractParameters(description_1 || '')), false), __read(extractParameters(content)), false))), _k = _j.next(); !_k.done; _k = _j.next()) {
                    var parameterName = _k.value;
                    dependentParameterNames.push(parameterName);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_k && !_k.done && (_f = _j.return)) _f.call(_j);
                }
                finally { if (e_4) throw e_4.error; }
            }
            if (executionType === 'SCRIPT') {
                try {
                    for (var _l = (e_5 = void 0, __values(extractVariables(content))), _m = _l.next(); !_m.done; _m = _l.next()) {
                        var parameterName = _m.value;
                        dependentParameterNames.push(parameterName);
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_m && !_m.done && (_g = _l.return)) _g.call(_l);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
            dependentParameterNames = __spreadArray([], __read(new Set(dependentParameterNames)), false);
            promptbookJson.promptTemplates.push({
                name: normalizeTo_PascalCase(section.title),
                title: section.title,
                description: description_1,
                dependentParameterNames: dependentParameterNames,
                executionType: executionType,
                jokers: jokers,
                postprocessing: postprocessing,
                expectAmount: expectAmount,
                expectFormat: expectFormat,
                modelRequirements: templateModelRequirements,
                contentLanguage: executionType === 'SCRIPT' ? language : undefined,
                content: content,
                resultingParameterName: resultingParameterName,
            });
        };
        try {
            for (var _c = __values(markdownStructure.sections), _d = _c.next(); !_d.done; _d = _c.next()) {
                var section = _d.value;
                _loop_1(section);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // =============================================================
        return promptbookJson;
    }
    /**
     * TODO: Report here line/column of error
     * TODO: Use spaceTrim more effectively
     * TODO: [🧠] Parameter flags - isInput, isOutput, isInternal
     */

    /**
     * This error indicates that the promptbook object has valid syntax but contains logical errors (like circular dependencies)
     */
    var PromptbookLogicError = /** @class */ (function (_super) {
        __extends(PromptbookLogicError, _super);
        function PromptbookLogicError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'PromptbookLogicError';
            Object.setPrototypeOf(_this, PromptbookLogicError.prototype);
            return _this;
        }
        return PromptbookLogicError;
    }(Error));

    /**
     * Tests if given string is valid URL.
     *
     * Note: Dataurl are considered perfectly valid.
     */
    function isValidUrl(url) {
        if (typeof url !== 'string') {
            return false;
        }
        try {
            if (url.startsWith('blob:')) {
                url = url.replace(/^blob:/, '');
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var urlObject = new URL(url);
            if (!['http:', 'https:', 'data:'].includes(urlObject.protocol)) {
                return false;
            }
            return true;
        }
        catch (error) {
            return false;
        }
    }

    /**
     * Validates PromptbookJson if it is logically valid.
     *
     * It checks:
     * -   if it has correct parameters dependency
     *
     * It does NOT check:
     * -   if it is valid json
     * -   if it is meaningful
     *
     * @param promptbook valid or invalid PromptbookJson
     * @throws {PromptbookLogicError} on logical error in the promptbook
     */
    function validatePromptbookJson(promptbook) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
        if (promptbook.promptbookUrl !== undefined) {
            if (!isValidUrl(promptbook.promptbookUrl)) {
                // TODO: This should be maybe the syntax error detected during parsing
                throw new PromptbookLogicError("Invalid promptbook URL \"".concat(promptbook.promptbookUrl, "\""));
            }
        }
        var _loop_1 = function (parameter) {
            if (parameter.isInput && parameter.isOutput) {
                throw new PromptbookLogicError("Parameter {".concat(parameter.name, "} can not be both input and output"));
            }
            // Note: Testing that parameter is either intermediate or output BUT not created and unused
            if (!parameter.isInput &&
                !parameter.isOutput &&
                !promptbook.promptTemplates.some(function (template) { return template.dependentParameterNames.includes(parameter.name); })) {
                throw new PromptbookLogicError(spaceTrim__default["default"]("\n                    Parameter {".concat(parameter.name, "} is created but not used\n\n                    You can declare {").concat(parameter.name, "} as output parameter by adding in the header:\n                    - OUTPUT PARAMETER `{").concat(parameter.name, "}` ").concat(parameter.description || '', "\n\n                ")));
            }
            // Note: Testing that parameter is either input or result of some template
            if (!parameter.isInput &&
                !promptbook.promptTemplates.some(function (template) { return template.resultingParameterName === parameter.name; })) {
                throw new PromptbookLogicError(spaceTrim__default["default"]("\n                    Parameter {".concat(parameter.name, "} is declared but not defined\n\n                    You can do one of these:\n                    - Remove declaration of {").concat(parameter.name, "}\n                    - Add prompt template that results in -> {").concat(parameter.name, "}\n\n                ")));
            }
        };
        try {
            // Note: Check each parameter individually
            for (var _e = __values(promptbook.parameters), _f = _e.next(); !_f.done; _f = _e.next()) {
                var parameter = _f.value;
                _loop_1(parameter);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Note: Check each template individually
        var definedParameters = new Set(promptbook.parameters.filter(function (_a) {
            var isInput = _a.isInput;
            return isInput;
        }).map(function (_a) {
            var name = _a.name;
            return name;
        }));
        try {
            for (var _g = __values(promptbook.promptTemplates), _h = _g.next(); !_h.done; _h = _g.next()) {
                var template = _h.value;
                if (definedParameters.has(template.resultingParameterName)) {
                    throw new PromptbookLogicError("Parameter {".concat(template.resultingParameterName, "} is defined multiple times"));
                }
                definedParameters.add(template.resultingParameterName);
                if (template.executionType === 'PROMPT_TEMPLATE' &&
                    (template.modelRequirements.modelVariant === undefined ||
                        template.modelRequirements.modelName === undefined)) {
                    throw new PromptbookLogicError(spaceTrim__default["default"]("\n\n                  You must specify MODEL VARIANT and MODEL NAME in the prompt template \"".concat(template.title, "\"\n\n                  For example:\n                  - MODEL VARIANT Chat\n                  - MODEL NAME `gpt-4-1106-preview`\n\n              ")));
                }
                if (template.jokers && template.jokers.length > 0) {
                    if (!template.expectFormat &&
                        !template.expectAmount /* <- TODO: Require at least 1 -> min <- expectation to use jokers */) {
                        throw new PromptbookLogicError("Joker parameters are used for {".concat(template.resultingParameterName, "} but no expectations are defined"));
                    }
                    try {
                        for (var _j = (e_3 = void 0, __values(template.jokers)), _k = _j.next(); !_k.done; _k = _j.next()) {
                            var joker = _k.value;
                            if (!template.dependentParameterNames.includes(joker)) {
                                throw new PromptbookLogicError("Parameter {".concat(joker, "} is used for {").concat(template.resultingParameterName, "} as joker but not in dependentParameterNames"));
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
                if (template.expectAmount) {
                    try {
                        for (var _l = (e_4 = void 0, __values(Object.entries(template.expectAmount))), _m = _l.next(); !_m.done; _m = _l.next()) {
                            var _o = __read(_m.value, 2), unit = _o[0], _p = _o[1], min = _p.min, max = _p.max;
                            if (min !== undefined && max !== undefined && min > max) {
                                throw new PromptbookLogicError("Min expectation (=".concat(min, ") of ").concat(unit, " is higher than max expectation (=").concat(max, ")"));
                            }
                            if (min !== undefined && min < 0) {
                                throw new PromptbookLogicError("Min expectation of ".concat(unit, " must be zero or positive"));
                            }
                            if (max !== undefined && max <= 0) {
                                throw new PromptbookLogicError("Max expectation of ".concat(unit, " must be positive"));
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // Note: Detect circular dependencies
        var resovedParameters = promptbook.parameters
            .filter(function (_a) {
            var isInput = _a.isInput;
            return isInput;
        })
            .map(function (_a) {
            var name = _a.name;
            return name;
        });
        var unresovedTemplates = __spreadArray([], __read(promptbook.promptTemplates), false);
        var loopLimit = LOOP_LIMIT;
        var _loop_2 = function () {
            if (loopLimit-- < 0) {
                throw new UnexpectedError('Loop limit reached during detection of circular dependencies in `validatePromptbookJson`');
            }
            var currentlyResovedTemplates = unresovedTemplates.filter(function (template) {
                return template.dependentParameterNames.every(function (name) { return resovedParameters.includes(name); });
            });
            if (currentlyResovedTemplates.length === 0) {
                throw new PromptbookLogicError(spaceTrim__default["default"](function (block) { return "\n\n                        Can not resolve some parameters\n                        It may be circular dependencies\n\n                        Can not resolve:\n                        ".concat(block(unresovedTemplates
                    .map(function (_a) {
                    var resultingParameterName = _a.resultingParameterName, dependentParameterNames = _a.dependentParameterNames;
                    return "- {".concat(resultingParameterName, "} depends on ").concat(dependentParameterNames
                        .map(function (dependentParameterName) { return "{".concat(dependentParameterName, "}"); })
                        .join(', '));
                })
                    .join('\n')), "\n\n                        Resolved:\n                        ").concat(block(resovedParameters.map(function (name) { return "- {".concat(name, "}"); }).join('\n')), "\n                    "); }));
            }
            resovedParameters = __spreadArray(__spreadArray([], __read(resovedParameters), false), __read(currentlyResovedTemplates.map(function (_a) {
                var resultingParameterName = _a.resultingParameterName;
                return resultingParameterName;
            })), false);
            unresovedTemplates = unresovedTemplates.filter(function (template) { return !currentlyResovedTemplates.includes(template); });
        };
        while (unresovedTemplates.length > 0) {
            _loop_2();
        }
    }
    /**
     * TODO: [🧠] Work with promptbookVersion
     * TODO: Use here some json-schema, Zod or something similar and change it to:
     *     > /**
     *     >  * Validates PromptbookJson if it is logically valid.
     *     >  *
     *     >  * It checks:
     *     >  * -   it has a valid structure
     *     >  * -   ...
     *     >  ex port function validatePromptbookJson(promptbook: unknown): asserts promptbook is PromptbookJson {
     */

    /**
     * This error occurs when some expectation is not met in the execution of the pipeline
     *
     * @private Always catched and rethrown as `PromptbookExecutionError`
     * Note: This is a kindof subtype of PromptbookExecutionError
     */
    var ExpectError = /** @class */ (function (_super) {
        __extends(ExpectError, _super);
        function ExpectError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'ExpectError';
            Object.setPrototypeOf(_this, ExpectError.prototype);
            return _this;
        }
        return ExpectError;
    }(Error));

    /**
     * Creates executor function from promptbook and execution tools.
     *
     * @returns The executor function
     * @throws {PromptbookLogicError} on logical error in the promptbook
     */
    function createPromptbookExecutor(options) {
        var _this = this;
        var promptbook = options.promptbook, tools = options.tools, _a = options.settings, settings = _a === void 0 ? {} : _a;
        var _b = settings.maxExecutionAttempts, maxExecutionAttempts = _b === void 0 ? 3 : _b;
        validatePromptbookJson(promptbook);
        var promptbookExecutor = function (inputParameters, onProgress) { return __awaiter(_this, void 0, void 0, function () {
            function executeSingleTemplate(currentTemplate) {
                return __awaiter(this, void 0, void 0, function () {
                    var name, title, priority, prompt, chatThread, completionResult, result, resultString, expectError, scriptExecutionErrors, maxAttempts, jokers, attempt, isJokerAttempt, joker, _a, _b, _c, _d, scriptTools, error_2, e_2_1, _e, _f, functionName, postprocessingError, _g, _h, scriptTools, error_3, e_3_1, e_4_1, _j, _k, _l, unit, _m, max, min, amount, error_4;
                    var e_2, _o, e_4, _p, e_3, _q, e_5, _r, _s;
                    return __generator(this, function (_t) {
                        switch (_t.label) {
                            case 0:
                                name = "promptbook-executor-frame-".concat(currentTemplate.name);
                                title = currentTemplate.title;
                                priority = promptbook.promptTemplates.length - promptbook.promptTemplates.indexOf(currentTemplate);
                                if (!onProgress /* <- [3] */) return [3 /*break*/, 2]; /* <- [3] */
                                return [4 /*yield*/, onProgress({
                                        name: name,
                                        title: title,
                                        isStarted: false,
                                        isDone: false,
                                        executionType: currentTemplate.executionType,
                                        parameterName: currentTemplate.resultingParameterName,
                                        parameterValue: null,
                                        // <- [3]
                                    })];
                            case 1:
                                _t.sent();
                                _t.label = 2;
                            case 2:
                                result = null;
                                resultString = null;
                                expectError = null;
                                maxAttempts = currentTemplate.executionType === 'PROMPT_DIALOG' ? Infinity : maxExecutionAttempts;
                                jokers = currentTemplate.jokers || [];
                                attempt = -jokers.length;
                                _t.label = 3;
                            case 3:
                                if (!(attempt < maxAttempts)) return [3 /*break*/, 49];
                                isJokerAttempt = attempt < 0;
                                joker = jokers[jokers.length + attempt];
                                if (isJokerAttempt && !joker) {
                                    throw new UnexpectedError("Joker not found in attempt ".concat(attempt));
                                }
                                result = null;
                                resultString = null;
                                expectError = null;
                                if (isJokerAttempt) {
                                    if (typeof parametersToPass[joker] === 'undefined') {
                                        throw new PromptbookExecutionError("Joker parameter {".concat(joker, "} not defined"));
                                    }
                                    resultString = parametersToPass[joker];
                                }
                                _t.label = 4;
                            case 4:
                                _t.trys.push([4, 45, 46, 47]);
                                if (!!isJokerAttempt) return [3 /*break*/, 27];
                                _a = currentTemplate.executionType;
                                switch (_a) {
                                    case 'SIMPLE_TEMPLATE': return [3 /*break*/, 5];
                                    case 'PROMPT_TEMPLATE': return [3 /*break*/, 6];
                                    case 'SCRIPT': return [3 /*break*/, 13];
                                    case 'PROMPT_DIALOG': return [3 /*break*/, 24];
                                }
                                return [3 /*break*/, 26];
                            case 5:
                                resultString = replaceParameters(currentTemplate.content, parametersToPass);
                                return [3 /*break*/, 27];
                            case 6:
                                prompt = {
                                    title: currentTemplate.title,
                                    promptbookUrl: "".concat(promptbook.promptbookUrl
                                        ? promptbook.promptbookUrl
                                        : 'anonymous' /* <- [🧠][🈴] How to deal with anonymous PROMPTBOOKs, do here some auto-url like SHA-256 based ad-hoc identifier? */, "#").concat(currentTemplate.name),
                                    parameters: parametersToPass,
                                    content: replaceParameters(currentTemplate.content, parametersToPass) /* <- [2] */,
                                    modelRequirements: currentTemplate.modelRequirements,
                                };
                                _b = currentTemplate.modelRequirements.modelVariant;
                                switch (_b) {
                                    case 'CHAT': return [3 /*break*/, 7];
                                    case 'COMPLETION': return [3 /*break*/, 9];
                                }
                                return [3 /*break*/, 11];
                            case 7: return [4 /*yield*/, tools.natural.gptChat(prompt)];
                            case 8:
                                chatThread = _t.sent();
                                // TODO: [🍬] Destroy chatThread
                                result = chatThread;
                                resultString = chatThread.content;
                                return [3 /*break*/, 12];
                            case 9: return [4 /*yield*/, tools.natural.gptComplete(prompt)];
                            case 10:
                                completionResult = _t.sent();
                                result = completionResult;
                                resultString = completionResult.content;
                                return [3 /*break*/, 12];
                            case 11: throw new PromptbookExecutionError("Unknown model variant \"".concat(currentTemplate.modelRequirements.modelVariant, "\""));
                            case 12: return [3 /*break*/, 27];
                            case 13:
                                if (tools.script.length === 0) {
                                    throw new PromptbookExecutionError('No script execution tools are available');
                                }
                                if (!currentTemplate.contentLanguage) {
                                    throw new PromptbookExecutionError("Script language is not defined for prompt template \"".concat(currentTemplate.name, "\""));
                                }
                                // TODO: DRY [1]
                                scriptExecutionErrors = [];
                                _t.label = 14;
                            case 14:
                                _t.trys.push([14, 21, 22, 23]);
                                _c = (e_2 = void 0, __values(tools.script)), _d = _c.next();
                                _t.label = 15;
                            case 15:
                                if (!!_d.done) return [3 /*break*/, 20];
                                scriptTools = _d.value;
                                _t.label = 16;
                            case 16:
                                _t.trys.push([16, 18, , 19]);
                                return [4 /*yield*/, scriptTools.execute({
                                        scriptLanguage: currentTemplate.contentLanguage,
                                        script: currentTemplate.content,
                                        parameters: parametersToPass,
                                    })];
                            case 17:
                                resultString = _t.sent();
                                return [3 /*break*/, 20];
                            case 18:
                                error_2 = _t.sent();
                                if (!(error_2 instanceof Error)) {
                                    throw error_2;
                                }
                                scriptExecutionErrors.push(error_2);
                                return [3 /*break*/, 19];
                            case 19:
                                _d = _c.next();
                                return [3 /*break*/, 15];
                            case 20: return [3 /*break*/, 23];
                            case 21:
                                e_2_1 = _t.sent();
                                e_2 = { error: e_2_1 };
                                return [3 /*break*/, 23];
                            case 22:
                                try {
                                    if (_d && !_d.done && (_o = _c.return)) _o.call(_c);
                                }
                                finally { if (e_2) throw e_2.error; }
                                return [7 /*endfinally*/];
                            case 23:
                                if (resultString) {
                                    return [3 /*break*/, 27];
                                }
                                if (scriptExecutionErrors.length === 1) {
                                    throw scriptExecutionErrors[0];
                                }
                                else {
                                    throw new PromptbookExecutionError(spaceTrim__default["default"](function (block) { return "\n                                              Script execution failed ".concat(scriptExecutionErrors.length, " times\n\n                                              ").concat(block(scriptExecutionErrors
                                        .map(function (error) { return '- ' + error.message; })
                                        .join('\n\n')), "\n                                          "); }));
                                }
                            case 24: return [4 /*yield*/, tools.userInterface.promptDialog({
                                    promptTitle: currentTemplate.title,
                                    promptMessage: replaceParameters(currentTemplate.description || '', parametersToPass),
                                    defaultValue: replaceParameters(currentTemplate.content, parametersToPass),
                                    // TODO: [🧠] !! Figure out how to define placeholder in .ptbk.md file
                                    placeholder: undefined,
                                    priority: priority,
                                })];
                            case 25:
                                // TODO: [🌹] When making next attempt for `PROMPT DIALOG`, preserve the previous user input
                                resultString = _t.sent();
                                return [3 /*break*/, 27];
                            case 26: throw new PromptbookExecutionError(
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            "Unknown execution type \"".concat(currentTemplate.executionType, "\""));
                            case 27:
                                if (!(!isJokerAttempt && currentTemplate.postprocessing)) return [3 /*break*/, 44];
                                _t.label = 28;
                            case 28:
                                _t.trys.push([28, 42, 43, 44]);
                                _e = (e_4 = void 0, __values(currentTemplate.postprocessing)), _f = _e.next();
                                _t.label = 29;
                            case 29:
                                if (!!_f.done) return [3 /*break*/, 41];
                                functionName = _f.value;
                                // TODO: DRY [1]
                                scriptExecutionErrors = [];
                                postprocessingError = null;
                                _t.label = 30;
                            case 30:
                                _t.trys.push([30, 37, 38, 39]);
                                _g = (e_3 = void 0, __values(tools.script)), _h = _g.next();
                                _t.label = 31;
                            case 31:
                                if (!!_h.done) return [3 /*break*/, 36];
                                scriptTools = _h.value;
                                _t.label = 32;
                            case 32:
                                _t.trys.push([32, 34, , 35]);
                                return [4 /*yield*/, scriptTools.execute({
                                        scriptLanguage: "javascript" /* <- TODO: Try it in each languages; In future allow postprocessing with arbitrary combination of languages to combine */,
                                        script: "".concat(functionName, "(resultString)"),
                                        parameters: __assign(__assign({}, parametersToPass), { resultString: resultString || '' }),
                                    })];
                            case 33:
                                resultString = _t.sent();
                                postprocessingError = null;
                                return [3 /*break*/, 36];
                            case 34:
                                error_3 = _t.sent();
                                if (!(error_3 instanceof Error)) {
                                    throw error_3;
                                }
                                postprocessingError = error_3;
                                scriptExecutionErrors.push(error_3);
                                return [3 /*break*/, 35];
                            case 35:
                                _h = _g.next();
                                return [3 /*break*/, 31];
                            case 36: return [3 /*break*/, 39];
                            case 37:
                                e_3_1 = _t.sent();
                                e_3 = { error: e_3_1 };
                                return [3 /*break*/, 39];
                            case 38:
                                try {
                                    if (_h && !_h.done && (_q = _g.return)) _q.call(_g);
                                }
                                finally { if (e_3) throw e_3.error; }
                                return [7 /*endfinally*/];
                            case 39:
                                if (postprocessingError) {
                                    throw postprocessingError;
                                }
                                _t.label = 40;
                            case 40:
                                _f = _e.next();
                                return [3 /*break*/, 29];
                            case 41: return [3 /*break*/, 44];
                            case 42:
                                e_4_1 = _t.sent();
                                e_4 = { error: e_4_1 };
                                return [3 /*break*/, 44];
                            case 43:
                                try {
                                    if (_f && !_f.done && (_p = _e.return)) _p.call(_e);
                                }
                                finally { if (e_4) throw e_4.error; }
                                return [7 /*endfinally*/];
                            case 44:
                                if (currentTemplate.expectFormat) {
                                    if (currentTemplate.expectFormat === 'JSON') {
                                        if (!isValidJsonString(resultString || '')) {
                                            throw new ExpectError('Expected valid JSON string');
                                        }
                                    }
                                }
                                if (currentTemplate.expectAmount) {
                                    try {
                                        for (_j = (e_5 = void 0, __values(Object.entries(currentTemplate.expectAmount))), _k = _j.next(); !_k.done; _k = _j.next()) {
                                            _l = __read(_k.value, 2), unit = _l[0], _m = _l[1], max = _m.max, min = _m.min;
                                            amount = CountUtils[unit.toUpperCase()](resultString || '');
                                            if (min && amount < min) {
                                                throw new ExpectError("Expected at least ".concat(min, " ").concat(unit, " but got ").concat(amount));
                                            } /* not else */
                                            if (max && amount > max) {
                                                throw new ExpectError("Expected at most ".concat(max, " ").concat(unit, " but got ").concat(amount));
                                            }
                                        }
                                    }
                                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                                    finally {
                                        try {
                                            if (_k && !_k.done && (_r = _j.return)) _r.call(_j);
                                        }
                                        finally { if (e_5) throw e_5.error; }
                                    }
                                }
                                return [3 /*break*/, 49];
                            case 45:
                                error_4 = _t.sent();
                                if (!(error_4 instanceof ExpectError)) {
                                    throw error_4;
                                }
                                expectError = error_4;
                                return [3 /*break*/, 47];
                            case 46:
                                if (!isJokerAttempt &&
                                    currentTemplate.executionType === 'PROMPT_TEMPLATE' &&
                                    prompt
                                //    <- Note:  [2] When some expected parameter is not defined, error will occur in replaceParameters
                                //              In that case we don’t want to make a report about it because it’s not a natural execution error
                                ) {
                                    // TODO: [🧠] Maybe put other executionTypes into report
                                    executionReport.promptExecutions.push({
                                        prompt: {
                                            title: currentTemplate.title /* <- Note: If title in promptbook contains emojis, pass it innto report */,
                                            content: prompt.content,
                                            modelRequirements: prompt.modelRequirements,
                                            // <- Note: Do want to pass ONLY wanted information to the report
                                        },
                                        result: result || undefined,
                                        error: expectError || undefined,
                                    });
                                }
                                return [7 /*endfinally*/];
                            case 47:
                                if (expectError !== null && attempt === maxAttempts - 1) {
                                    throw new PromptbookExecutionError(spaceTrim__default["default"](function (block) { return "\n                              Natural execution failed ".concat(maxExecutionAttempts, "x\n\n                              ").concat(block((expectError === null || expectError === void 0 ? void 0 : expectError.message) || ''), "\n                          "); }));
                                }
                                _t.label = 48;
                            case 48:
                                attempt++;
                                return [3 /*break*/, 3];
                            case 49:
                                if (resultString === null) {
                                    throw new UnexpectedError('Something went wrong and prompt result is null');
                                }
                                if (onProgress /* <- [3] */) {
                                    onProgress({
                                        name: name,
                                        title: title,
                                        isStarted: true,
                                        isDone: true,
                                        executionType: currentTemplate.executionType,
                                        parameterName: currentTemplate.resultingParameterName,
                                        parameterValue: resultString,
                                        // <- [3]
                                    });
                                }
                                parametersToPass = __assign(__assign({}, parametersToPass), (_s = {}, _s[currentTemplate.resultingParameterName] = resultString /* <- Note: Not need to detect parameter collision here because Promptbook checks logic consistency during construction */, _s));
                                return [2 /*return*/];
                        }
                    });
                });
            }
            var parametersToPass, executionReport, resovedParameters_1, unresovedTemplates, resolving_1, loopLimit, _loop_1, error_1, _a, _b, parameter;
            var e_1, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        parametersToPass = inputParameters;
                        executionReport = {
                            promptbookUrl: promptbook.promptbookUrl,
                            title: promptbook.title,
                            promptbookUsedVersion: PROMPTBOOK_VERSION,
                            promptbookRequestedVersion: promptbook.promptbookVersion,
                            description: promptbook.description,
                            promptExecutions: [],
                        };
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, , 7]);
                        resovedParameters_1 = promptbook.parameters
                            .filter(function (_a) {
                            var isInput = _a.isInput;
                            return isInput;
                        })
                            .map(function (_a) {
                            var name = _a.name;
                            return name;
                        });
                        unresovedTemplates = __spreadArray([], __read(promptbook.promptTemplates), false);
                        resolving_1 = [];
                        loopLimit = LOOP_LIMIT;
                        _loop_1 = function () {
                            var currentTemplate, work_1;
                            return __generator(this, function (_e) {
                                switch (_e.label) {
                                    case 0:
                                        if (loopLimit-- < 0) {
                                            throw new UnexpectedError('Loop limit reached during resolving parameters promptbook execution');
                                        }
                                        currentTemplate = unresovedTemplates.find(function (template) {
                                            return template.dependentParameterNames.every(function (name) { return resovedParameters_1.includes(name); });
                                        });
                                        if (!(!currentTemplate && resolving_1.length === 0)) return [3 /*break*/, 1];
                                        throw new UnexpectedError(spaceTrim__default["default"]("\n                            Can not resolve some parameters\n\n                            Note: This should be catched during validatePromptbookJson\n                        "));
                                    case 1:
                                        if (!!currentTemplate) return [3 /*break*/, 3];
                                        /* [5] */ return [4 /*yield*/, Promise.race(resolving_1)];
                                    case 2:
                                        /* [5] */ _e.sent();
                                        return [3 /*break*/, 4];
                                    case 3:
                                        unresovedTemplates = unresovedTemplates.filter(function (template) { return template !== currentTemplate; });
                                        work_1 = executeSingleTemplate(currentTemplate)
                                            .then(function () {
                                            resovedParameters_1 = __spreadArray(__spreadArray([], __read(resovedParameters_1), false), [currentTemplate.resultingParameterName], false);
                                        })
                                            .then(function () {
                                            resolving_1 = resolving_1.filter(function (w) { return w !== work_1; });
                                        });
                                        resolving_1.push(work_1);
                                        _e.label = 4;
                                    case 4: return [2 /*return*/];
                                }
                            });
                        };
                        _d.label = 2;
                    case 2:
                        if (!(unresovedTemplates.length > 0)) return [3 /*break*/, 4];
                        return [5 /*yield**/, _loop_1()];
                    case 3:
                        _d.sent();
                        return [3 /*break*/, 2];
                    case 4: return [4 /*yield*/, Promise.all(resolving_1)];
                    case 5:
                        _d.sent();
                        return [3 /*break*/, 7];
                    case 6:
                        error_1 = _d.sent();
                        if (!(error_1 instanceof Error)) {
                            throw error_1;
                        }
                        return [2 /*return*/, {
                                isSuccessful: false,
                                errors: [error_1],
                                executionReport: executionReport,
                                outputParameters: parametersToPass,
                            }];
                    case 7:
                        try {
                            // Note: Filter ONLY output parameters
                            for (_a = __values(promptbook.parameters), _b = _a.next(); !_b.done; _b = _a.next()) {
                                parameter = _b.value;
                                if (parameter.isOutput) {
                                    continue;
                                }
                                delete parametersToPass[parameter.name];
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        return [2 /*return*/, {
                                isSuccessful: true,
                                errors: [],
                                executionReport: executionReport,
                                outputParameters: parametersToPass,
                            }];
                }
            });
        }); };
        return promptbookExecutor;
    }
    /**
     * TODO: [🧠] When not meet expectations in PROMPT_DIALOG, make some way to tell the user
     * TODO: [👧] Strongly type the executors to avoid need of remove nullables whtn noUncheckedIndexedAccess in tsconfig.json
     * Note: CreatePromptbookExecutorOptions are just connected to PromptbookExecutor so do not extract to types folder
     * TODO: [🧠][3] transparent = (report intermediate parameters) / opaque execution = (report only output parameters) progress reporting mode
     */

    /**
     * Get current date in ISO 8601 format
     *
     * @private This is internal util of the promptbook
     */
    function getCurrentIsoDate() {
        return new Date().toISOString();
    }

    /**
     * Mocked execution Tools for just echoing the requests for testing purposes.
     */
    var MockedEchoNaturalExecutionTools = /** @class */ (function () {
        function MockedEchoNaturalExecutionTools(options) {
            this.options = options;
        }
        /**
         * Mocks chat model
         */
        MockedEchoNaturalExecutionTools.prototype.gptChat = function (prompt) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (this.options.isVerbose) {
                        console.info('💬 Mocked gptChat call');
                    }
                    return [2 /*return*/, {
                            content: spaceTrim__default["default"](function (block) { return "\n                    You said:\n                    ".concat(block(prompt.content), "\n                "); }),
                            model: 'mocked-echo',
                            timing: {
                                start: getCurrentIsoDate(),
                                complete: getCurrentIsoDate(),
                            },
                            usage: {
                                price: 0,
                                inputTokens: 0,
                                outputTokens: 0,
                            },
                            rawResponse: {
                                note: 'This is mocked echo',
                            },
                            // <- [🤹‍♂️]
                        }];
                });
            });
        };
        /**
         * Mocks completion model
         */
        MockedEchoNaturalExecutionTools.prototype.gptComplete = function (prompt) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (this.options.isVerbose) {
                        console.info('🖋 Mocked gptComplete call');
                    }
                    return [2 /*return*/, {
                            content: spaceTrim__default["default"](function (block) { return "\n                    ".concat(block(prompt.content), "\n                    And so on...\n                "); }),
                            model: 'mocked-echo',
                            timing: {
                                start: getCurrentIsoDate(),
                                complete: getCurrentIsoDate(),
                            },
                            usage: {
                                price: 0,
                                inputTokens: 0,
                                outputTokens: 0,
                            },
                            rawResponse: {
                                note: 'This is mocked echo',
                            },
                            // <- [🤹‍♂️]
                        }];
                });
            });
        };
        return MockedEchoNaturalExecutionTools;
    }());
    /**
     * TODO: Allow in spaceTrim: nesting with > ${block(prompt.request)}
     */

    /**
     * Delagates the user interaction to a async callback function
     * You need to provide your own implementation of this callback function and its bind to UI.
     */
    var CallbackInterfaceTools = /** @class */ (function () {
        function CallbackInterfaceTools(options) {
            this.options = options;
        }
        /**
         * Trigger the custom callback function
         */
        CallbackInterfaceTools.prototype.promptDialog = function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var answer;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.options.callback(options)];
                        case 1:
                            answer = _a.sent();
                            if (this.options.isVerbose) {
                                console.info(spaceTrim__default["default"](function (block) { return "\n                        \uD83D\uDCD6 ".concat(block(options.promptTitle), "\n                        \uD83D\uDC64 ").concat(block(answer), "\n                    "); }));
                            }
                            return [2 /*return*/, answer];
                    }
                });
            });
        };
        return CallbackInterfaceTools;
    }());

    /**
     * Wrapper around `window.prompt` synchronous function that interacts with the user via browser prompt
     *
     * Warning: It is used for testing and mocking
     *          **NOT intended to use in the production** due to its synchronous nature.
     */
    var SimplePromptInterfaceTools = /** @class */ (function () {
        function SimplePromptInterfaceTools(options) {
            this.options = options;
        }
        /**
         * Trigger window.PROMPT DIALOG
         */
        SimplePromptInterfaceTools.prototype.promptDialog = function (options) {
            return __awaiter(this, void 0, void 0, function () {
                var answer;
                return __generator(this, function (_a) {
                    answer = window.prompt(spaceTrim__default["default"](function (block) { return "\n                    ".concat(block(options.promptTitle), "\n\n                    ").concat(block(options.promptMessage), "\n                "); }));
                    if (this.options.isVerbose) {
                        console.info(spaceTrim__default["default"](function (block) { return "\n                        \uD83D\uDCD6 ".concat(block(options.promptTitle), "\n                        \uD83D\uDC64 ").concat(block(answer || '🚫 User cancelled prompt'), "\n                    "); }));
                    }
                    if (answer === null) {
                        throw new PromptbookExecutionError('User cancelled prompt');
                    }
                    return [2 /*return*/, answer];
                });
            });
        };
        return SimplePromptInterfaceTools;
    }());

    /**
     * This error indicates that promptbook not found in the library
     */
    var PromptbookNotFoundError = /** @class */ (function (_super) {
        __extends(PromptbookNotFoundError, _super);
        function PromptbookNotFoundError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'PromptbookNotFoundError';
            Object.setPrototypeOf(_this, PromptbookNotFoundError.prototype);
            return _this;
        }
        return PromptbookNotFoundError;
    }(Error));

    /**
     * This error indicates errors in referencing promptbooks between each other
     */
    var PromptbookReferenceError = /** @class */ (function (_super) {
        __extends(PromptbookReferenceError, _super);
        function PromptbookReferenceError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = 'PromptbookReferenceError';
            Object.setPrototypeOf(_this, PromptbookReferenceError.prototype);
            return _this;
        }
        return PromptbookReferenceError;
    }(Error));

    /**
     * Library of promptbooks that groups together promptbooks for an application.
     * This implementation is a very thin wrapper around the Array / Map of promptbooks.
     *
     * @see https://github.com/webgptorg/promptbook#promptbook-library
     */
    var SimplePromptbookLibrary = /** @class */ (function () {
        /**!!!
         *
         * @param promptbooks !!!
         *
         * Note: During the construction logic of all promptbooks are validated
         * Note: It is not recommended to use this constructor directly, use `createPromptbookLibraryFromSources` *(or other variant)* instead
         */
        function SimplePromptbookLibrary() {
            var e_1, _a;
            var promptbooks = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                promptbooks[_i] = arguments[_i];
            }
            this.library = new Map();
            try {
                for (var promptbooks_1 = __values(promptbooks), promptbooks_1_1 = promptbooks_1.next(); !promptbooks_1_1.done; promptbooks_1_1 = promptbooks_1.next()) {
                    var promptbook = promptbooks_1_1.value;
                    if (promptbook.promptbookUrl === undefined) {
                        throw new PromptbookReferenceError(spaceTrim__default["default"]("\n                        Promptbook with name \"".concat(promptbook.title, "\" does not have defined URL\n\n                        Note: Promptbooks without URLs are called anonymous promptbooks\n                              They can be used as standalone promptbooks, but they cannot be referenced by other promptbooks\n                              And also they cannot be used in the promptbook library\n\n                    ")));
                    }
                    validatePromptbookJson(promptbook);
                    this.library.set(promptbook.promptbookUrl, promptbook);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (promptbooks_1_1 && !promptbooks_1_1.done && (_a = promptbooks_1.return)) _a.call(promptbooks_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        /**
         * Gets all promptbooks in the library
         */
        SimplePromptbookLibrary.prototype.listPromptbooks = function () {
            return Array.from(this.library.keys());
        };
        /**
         * Gets promptbook by its URL
         *
         * Note: This is not a direct fetching from the URL, but a lookup in the library
         */
        SimplePromptbookLibrary.prototype.getPromptbookByUrl = function (url) {
            var _this = this;
            var promptbook = this.library.get(url);
            if (!promptbook) {
                throw new PromptbookNotFoundError(spaceTrim__default["default"](function (block) { return "\n                        Promptbook with url \"".concat(url, "\" not found\n\n                        Available promptbooks:\n                        ").concat(block(_this.listPromptbooks()
                    .map(function (promptbookUrl) { return "- ".concat(promptbookUrl); })
                    .join('\n')), "\n\n                    "); }));
            }
            return promptbook;
        };
        /**
         * Checks whether given prompt was defined in any promptbook in the library
         */
        SimplePromptbookLibrary.prototype.isResponsibleForPrompt = function (prompt) {
            return true;
        };
        return SimplePromptbookLibrary;
    }());

    function createPromptbookLibraryFromSources() {
        var e_1, _a;
        var promptbookSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            promptbookSources[_i] = arguments[_i];
        }
        var promptbooks = new Array();
        try {
            for (var promptbookSources_1 = __values(promptbookSources), promptbookSources_1_1 = promptbookSources_1.next(); !promptbookSources_1_1.done; promptbookSources_1_1 = promptbookSources_1.next()) {
                var source = promptbookSources_1_1.value;
                var promptbook = void 0;
                if (typeof source === 'string') {
                    // Note: When directly creating from string, no need to validate the source
                    //       The validation is performed always before execution
                    promptbook = promptbookStringToJson(source);
                }
                else {
                    promptbook = source;
                }
                promptbooks.push(promptbook);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (promptbookSources_1_1 && !promptbookSources_1_1.done && (_a = promptbookSources_1.return)) _a.call(promptbookSources_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return new (SimplePromptbookLibrary.bind.apply(SimplePromptbookLibrary, __spreadArray([void 0], __read(promptbooks), false)))();
    }
    /**
     * Constructs Promptbook from any sources
     *
     * Note: During the construction syntax and logic of all sources are validated
     * Note: You can combine .ptbk.md and .ptbk.json files BUT it is not recommended
     *
     * @param promptbookSources contents of .ptbk.md or .ptbk.json files
     * @param settings settings for creating executor functions
     * @returns PromptbookLibrary
     */
    /***
     * TODO: !!! Annotate all + all to README and samples
     */

    function createPromptbookLibraryFromPromise(promptbookSourcesPromiseOrFactory) {
        var library;
        function forSources() {
            return __awaiter(this, void 0, void 0, function () {
                var promptbookSources;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (typeof promptbookSourcesPromiseOrFactory === 'function') {
                                // Note: Calling factory function only once despite multiple calls to resolveSources
                                promptbookSourcesPromiseOrFactory = promptbookSourcesPromiseOrFactory();
                            }
                            return [4 /*yield*/, promptbookSourcesPromiseOrFactory];
                        case 1:
                            promptbookSources = _a.sent();
                            library = createPromptbookLibraryFromSources.apply(void 0, __spreadArray([], __read(promptbookSources), false));
                            return [2 /*return*/];
                    }
                });
            });
        }
        function listPromptbooks() {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, forSources()];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, /* not await */ library.listPromptbooks()];
                    }
                });
            });
        }
        function getPromptbookByUrl(url) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, forSources()];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, /* not await */ library.getPromptbookByUrl(url)];
                    }
                });
            });
        }
        function isResponsibleForPrompt(prompt) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, forSources()];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, /* not await */ library.isResponsibleForPrompt(prompt)];
                    }
                });
            });
        }
        return {
            listPromptbooks: listPromptbooks,
            getPromptbookByUrl: getPromptbookByUrl,
            isResponsibleForPrompt: isResponsibleForPrompt,
        };
    }
    /***
     * TODO: !!! Annotate all + all to README and samples
     */

    function createPromptbookSublibrary(library, predicate) {
        function listPromptbooks() {
            return __awaiter(this, void 0, void 0, function () {
                var promptbooks;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, library.listPromptbooks()];
                        case 1:
                            promptbooks = _a.sent();
                            promptbooks = promptbooks.filter(predicate);
                            return [2 /*return*/, promptbooks];
                    }
                });
            });
        }
        function getPromptbookByUrl(url) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, promptbook;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!!predicate(url)) return [3 /*break*/, 2];
                            _a = PromptbookNotFoundError.bind;
                            return [4 /*yield*/, spaceTrim__default["default"](function (block) { return __awaiter(_this, void 0, void 0, function () {
                                    var _a, _b, _c, _d, _e, _f;
                                    return __generator(this, function (_g) {
                                        switch (_g.label) {
                                            case 0:
                                                _c = (_b = "\n                        Promptbook with url \"".concat(url, "\" not found or not accessible\n\n                        Available promptbooks:\n                        ")).concat;
                                                _d = block;
                                                return [4 /*yield*/, listPromptbooks()];
                                            case 1:
                                                _e = (_a = _c.apply(_b, [_d.apply(void 0, [(_g.sent()).map(function (promptbookUrl) { return "- ".concat(promptbookUrl); }).join('\n')]), "\n\n                        All available promptbooks in parent library:\n                        "])).concat;
                                                _f = block;
                                                return [4 /*yield*/, library.listPromptbooks()];
                                            case 2: return [2 /*return*/, _e.apply(_a, [_f.apply(void 0, [(_g.sent()).map(function (promptbookUrl) { return "- ".concat(promptbookUrl); }).join('\n')]), "\n\n                    "])];
                                        }
                                    });
                                }); })];
                        case 1: throw new (_a.apply(PromptbookNotFoundError, [void 0, _b.sent()]))();
                        case 2: return [4 /*yield*/, library.getPromptbookByUrl(url)];
                        case 3:
                            promptbook = _b.sent();
                            return [2 /*return*/, promptbook];
                    }
                });
            });
        }
        function isResponsibleForPrompt(prompt) {
            return __awaiter(this, void 0, void 0, function () {
                var isResponsible;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, library.isResponsibleForPrompt(prompt)];
                        case 1:
                            isResponsible = _a.sent();
                            // TODO: !! Only if responsible, check if predicate is true
                            return [2 /*return*/, isResponsible];
                    }
                });
            });
        }
        return {
            listPromptbooks: listPromptbooks,
            getPromptbookByUrl: getPromptbookByUrl,
            isResponsibleForPrompt: isResponsibleForPrompt,
        };
    }
    /***
     * TODO: !!! Annotate all + all to README and samples
     */

    exports.CallbackInterfaceTools = CallbackInterfaceTools;
    exports.ExecutionTypes = ExecutionTypes;
    exports.MockedEchoNaturalExecutionTools = MockedEchoNaturalExecutionTools;
    exports.PROMPTBOOK_VERSION = PROMPTBOOK_VERSION;
    exports.SimplePromptInterfaceTools = SimplePromptInterfaceTools;
    exports.SimplePromptbookLibrary = SimplePromptbookLibrary;
    exports.createPromptbookExecutor = createPromptbookExecutor;
    exports.createPromptbookLibraryFromPromise = createPromptbookLibraryFromPromise;
    exports.createPromptbookLibraryFromSources = createPromptbookLibraryFromSources;
    exports.createPromptbookSublibrary = createPromptbookSublibrary;
    exports.promptbookStringToJson = promptbookStringToJson;
    exports.validatePromptbookJson = validatePromptbookJson;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.umd.js.map
